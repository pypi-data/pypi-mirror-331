# coding: utf-8

"""
    Skyfire SDK

    The Skyfire SDK is designed to allow agents to interact with the Skyfire platform to enable autonomous payments.

    The version of the OpenAPI document: 1.0.0
    Contact: support@skyfire.xyz
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from datetime import date
from pydantic import Field, StrictBool, StrictFloat, StrictInt, StrictStr, field_validator
from typing import Optional, Union
from typing_extensions import Annotated
from skyfire_sdk.models.vetric_facebook_event_search_response import VetricFacebookEventSearchResponse
from skyfire_sdk.models.vetric_facebook_user_search_response import VetricFacebookUserSearchResponse
from skyfire_sdk.models.vetric_instagram_location_map_response import VetricInstagramLocationMapResponse
from skyfire_sdk.models.vetric_instagram_user_search_response import VetricInstagramUserSearchResponse
from skyfire_sdk.models.vetric_linked_in_company_people_response import VetricLinkedInCompanyPeopleResponse
from skyfire_sdk.models.vetric_linked_in_job_search_response import VetricLinkedInJobSearchResponse
from skyfire_sdk.models.vetric_linked_in_people_search_response import VetricLinkedInPeopleSearchResponse
from skyfire_sdk.models.vetric_marketplace_search_response import VetricMarketplaceSearchResponse
from skyfire_sdk.models.vetric_twitter_top_search_response import VetricTwitterTopSearchResponse

from skyfire_sdk.api_client import ApiClient, RequestSerialized
from skyfire_sdk.api_response import ApiResponse
from skyfire_sdk.rest import RESTResponseType


class VetricApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def facebook_event_search(
        self,
        typed_query: Annotated[StrictStr, Field(description="The text query to search for events.")],
        end_cursor: Annotated[Optional[StrictStr], Field(description="Use this optional parameter to paginate through results. Retrieve the `end_cursor` value from the path `data.search_query.combined_results.page_info.end_cursor` in the response.")] = None,
        event_start_date: Annotated[Optional[date], Field(description="Filter events by their start date. Accepts a date string in the format `YYYY-MM-DD` ranging from `2020-01-01` to `2100-12-31`.")] = None,
        event_end_date: Annotated[Optional[date], Field(description="Filter events by their end date. Accepts a date string in the format `YYYY-MM-DD` ranging from `2020-01-01` to `2100-12-31`.")] = None,
        disable_bloks: Annotated[Optional[StrictBool], Field(description="Disable Bloks. The default value is `false`.")] = None,
        transform: Annotated[Optional[StrictBool], Field(description="Set to `true` to apply data transformation. The default value is `false`.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> VetricFacebookEventSearchResponse:
        """Facebook Event Search (Proxy)

        This endpoint returns events based on a specified search query, start date, and end date. Pagination can be controlled using the `end_cursor` parameter.

        :param typed_query: The text query to search for events. (required)
        :type typed_query: str
        :param end_cursor: Use this optional parameter to paginate through results. Retrieve the `end_cursor` value from the path `data.search_query.combined_results.page_info.end_cursor` in the response.
        :type end_cursor: str
        :param event_start_date: Filter events by their start date. Accepts a date string in the format `YYYY-MM-DD` ranging from `2020-01-01` to `2100-12-31`.
        :type event_start_date: date
        :param event_end_date: Filter events by their end date. Accepts a date string in the format `YYYY-MM-DD` ranging from `2020-01-01` to `2100-12-31`.
        :type event_end_date: date
        :param disable_bloks: Disable Bloks. The default value is `false`.
        :type disable_bloks: bool
        :param transform: Set to `true` to apply data transformation. The default value is `false`.
        :type transform: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._facebook_event_search_serialize(
            typed_query=typed_query,
            end_cursor=end_cursor,
            event_start_date=event_start_date,
            event_end_date=event_end_date,
            disable_bloks=disable_bloks,
            transform=transform,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VetricFacebookEventSearchResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def facebook_event_search_with_http_info(
        self,
        typed_query: Annotated[StrictStr, Field(description="The text query to search for events.")],
        end_cursor: Annotated[Optional[StrictStr], Field(description="Use this optional parameter to paginate through results. Retrieve the `end_cursor` value from the path `data.search_query.combined_results.page_info.end_cursor` in the response.")] = None,
        event_start_date: Annotated[Optional[date], Field(description="Filter events by their start date. Accepts a date string in the format `YYYY-MM-DD` ranging from `2020-01-01` to `2100-12-31`.")] = None,
        event_end_date: Annotated[Optional[date], Field(description="Filter events by their end date. Accepts a date string in the format `YYYY-MM-DD` ranging from `2020-01-01` to `2100-12-31`.")] = None,
        disable_bloks: Annotated[Optional[StrictBool], Field(description="Disable Bloks. The default value is `false`.")] = None,
        transform: Annotated[Optional[StrictBool], Field(description="Set to `true` to apply data transformation. The default value is `false`.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[VetricFacebookEventSearchResponse]:
        """Facebook Event Search (Proxy)

        This endpoint returns events based on a specified search query, start date, and end date. Pagination can be controlled using the `end_cursor` parameter.

        :param typed_query: The text query to search for events. (required)
        :type typed_query: str
        :param end_cursor: Use this optional parameter to paginate through results. Retrieve the `end_cursor` value from the path `data.search_query.combined_results.page_info.end_cursor` in the response.
        :type end_cursor: str
        :param event_start_date: Filter events by their start date. Accepts a date string in the format `YYYY-MM-DD` ranging from `2020-01-01` to `2100-12-31`.
        :type event_start_date: date
        :param event_end_date: Filter events by their end date. Accepts a date string in the format `YYYY-MM-DD` ranging from `2020-01-01` to `2100-12-31`.
        :type event_end_date: date
        :param disable_bloks: Disable Bloks. The default value is `false`.
        :type disable_bloks: bool
        :param transform: Set to `true` to apply data transformation. The default value is `false`.
        :type transform: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._facebook_event_search_serialize(
            typed_query=typed_query,
            end_cursor=end_cursor,
            event_start_date=event_start_date,
            event_end_date=event_end_date,
            disable_bloks=disable_bloks,
            transform=transform,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VetricFacebookEventSearchResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def facebook_event_search_without_preload_content(
        self,
        typed_query: Annotated[StrictStr, Field(description="The text query to search for events.")],
        end_cursor: Annotated[Optional[StrictStr], Field(description="Use this optional parameter to paginate through results. Retrieve the `end_cursor` value from the path `data.search_query.combined_results.page_info.end_cursor` in the response.")] = None,
        event_start_date: Annotated[Optional[date], Field(description="Filter events by their start date. Accepts a date string in the format `YYYY-MM-DD` ranging from `2020-01-01` to `2100-12-31`.")] = None,
        event_end_date: Annotated[Optional[date], Field(description="Filter events by their end date. Accepts a date string in the format `YYYY-MM-DD` ranging from `2020-01-01` to `2100-12-31`.")] = None,
        disable_bloks: Annotated[Optional[StrictBool], Field(description="Disable Bloks. The default value is `false`.")] = None,
        transform: Annotated[Optional[StrictBool], Field(description="Set to `true` to apply data transformation. The default value is `false`.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Facebook Event Search (Proxy)

        This endpoint returns events based on a specified search query, start date, and end date. Pagination can be controlled using the `end_cursor` parameter.

        :param typed_query: The text query to search for events. (required)
        :type typed_query: str
        :param end_cursor: Use this optional parameter to paginate through results. Retrieve the `end_cursor` value from the path `data.search_query.combined_results.page_info.end_cursor` in the response.
        :type end_cursor: str
        :param event_start_date: Filter events by their start date. Accepts a date string in the format `YYYY-MM-DD` ranging from `2020-01-01` to `2100-12-31`.
        :type event_start_date: date
        :param event_end_date: Filter events by their end date. Accepts a date string in the format `YYYY-MM-DD` ranging from `2020-01-01` to `2100-12-31`.
        :type event_end_date: date
        :param disable_bloks: Disable Bloks. The default value is `false`.
        :type disable_bloks: bool
        :param transform: Set to `true` to apply data transformation. The default value is `false`.
        :type transform: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._facebook_event_search_serialize(
            typed_query=typed_query,
            end_cursor=end_cursor,
            event_start_date=event_start_date,
            event_end_date=event_end_date,
            disable_bloks=disable_bloks,
            transform=transform,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VetricFacebookEventSearchResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _facebook_event_search_serialize(
        self,
        typed_query,
        end_cursor,
        event_start_date,
        event_end_date,
        disable_bloks,
        transform,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if typed_query is not None:
            
            _query_params.append(('typed_query', typed_query))
            
        if end_cursor is not None:
            
            _query_params.append(('end_cursor', end_cursor))
            
        if event_start_date is not None:
            if isinstance(event_start_date, date):
                _query_params.append(
                    (
                        'event_start_date',
                        event_start_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('event_start_date', event_start_date))
            
        if event_end_date is not None:
            if isinstance(event_end_date, date):
                _query_params.append(
                    (
                        'event_end_date',
                        event_end_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('event_end_date', event_end_date))
            
        if disable_bloks is not None:
            
            _query_params.append(('disable_bloks', disable_bloks))
            
        if transform is not None:
            
            _query_params.append(('transform', transform))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/proxy/vetric-facebook/facebook/v1/search/events',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def facebook_user_search(
        self,
        typed_query: Annotated[StrictStr, Field(description="The text query for searching users.")],
        end_cursor: Annotated[Optional[StrictStr], Field(description="Use this optional parameter to paginate through results. Retrieve the `end_cursor` value from the path `data.search_query.combined_results.page_info.end_cursor` in the response.")] = None,
        city_id: Annotated[Optional[StrictStr], Field(description="Numeric ID of a location. You can find this ID using the Search Filters (helper) endpoint at the bottom of the Search section.")] = None,
        education_id: Annotated[Optional[StrictStr], Field(description="Numeric ID of a school. You can find this ID using the Search Filters (helper) endpoint.")] = None,
        work_id: Annotated[Optional[StrictStr], Field(description="Numeric ID of a company. You can find this ID using the Search Filters (helper) endpoint.")] = None,
        disable_bloks: Annotated[Optional[StrictBool], Field(description="Disable Bloks. The default value is `false`.")] = None,
        transform: Annotated[Optional[StrictBool], Field(description="Set to `true` to apply data transformation. The default value is `false`.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> VetricFacebookUserSearchResponse:
        """Facebook People Search (Proxy)

        This endpoint returns users based on the specified search query and filters like location, education, and work. The search can be paginated using the `end_cursor` parameter.

        :param typed_query: The text query for searching users. (required)
        :type typed_query: str
        :param end_cursor: Use this optional parameter to paginate through results. Retrieve the `end_cursor` value from the path `data.search_query.combined_results.page_info.end_cursor` in the response.
        :type end_cursor: str
        :param city_id: Numeric ID of a location. You can find this ID using the Search Filters (helper) endpoint at the bottom of the Search section.
        :type city_id: str
        :param education_id: Numeric ID of a school. You can find this ID using the Search Filters (helper) endpoint.
        :type education_id: str
        :param work_id: Numeric ID of a company. You can find this ID using the Search Filters (helper) endpoint.
        :type work_id: str
        :param disable_bloks: Disable Bloks. The default value is `false`.
        :type disable_bloks: bool
        :param transform: Set to `true` to apply data transformation. The default value is `false`.
        :type transform: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._facebook_user_search_serialize(
            typed_query=typed_query,
            end_cursor=end_cursor,
            city_id=city_id,
            education_id=education_id,
            work_id=work_id,
            disable_bloks=disable_bloks,
            transform=transform,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VetricFacebookUserSearchResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def facebook_user_search_with_http_info(
        self,
        typed_query: Annotated[StrictStr, Field(description="The text query for searching users.")],
        end_cursor: Annotated[Optional[StrictStr], Field(description="Use this optional parameter to paginate through results. Retrieve the `end_cursor` value from the path `data.search_query.combined_results.page_info.end_cursor` in the response.")] = None,
        city_id: Annotated[Optional[StrictStr], Field(description="Numeric ID of a location. You can find this ID using the Search Filters (helper) endpoint at the bottom of the Search section.")] = None,
        education_id: Annotated[Optional[StrictStr], Field(description="Numeric ID of a school. You can find this ID using the Search Filters (helper) endpoint.")] = None,
        work_id: Annotated[Optional[StrictStr], Field(description="Numeric ID of a company. You can find this ID using the Search Filters (helper) endpoint.")] = None,
        disable_bloks: Annotated[Optional[StrictBool], Field(description="Disable Bloks. The default value is `false`.")] = None,
        transform: Annotated[Optional[StrictBool], Field(description="Set to `true` to apply data transformation. The default value is `false`.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[VetricFacebookUserSearchResponse]:
        """Facebook People Search (Proxy)

        This endpoint returns users based on the specified search query and filters like location, education, and work. The search can be paginated using the `end_cursor` parameter.

        :param typed_query: The text query for searching users. (required)
        :type typed_query: str
        :param end_cursor: Use this optional parameter to paginate through results. Retrieve the `end_cursor` value from the path `data.search_query.combined_results.page_info.end_cursor` in the response.
        :type end_cursor: str
        :param city_id: Numeric ID of a location. You can find this ID using the Search Filters (helper) endpoint at the bottom of the Search section.
        :type city_id: str
        :param education_id: Numeric ID of a school. You can find this ID using the Search Filters (helper) endpoint.
        :type education_id: str
        :param work_id: Numeric ID of a company. You can find this ID using the Search Filters (helper) endpoint.
        :type work_id: str
        :param disable_bloks: Disable Bloks. The default value is `false`.
        :type disable_bloks: bool
        :param transform: Set to `true` to apply data transformation. The default value is `false`.
        :type transform: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._facebook_user_search_serialize(
            typed_query=typed_query,
            end_cursor=end_cursor,
            city_id=city_id,
            education_id=education_id,
            work_id=work_id,
            disable_bloks=disable_bloks,
            transform=transform,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VetricFacebookUserSearchResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def facebook_user_search_without_preload_content(
        self,
        typed_query: Annotated[StrictStr, Field(description="The text query for searching users.")],
        end_cursor: Annotated[Optional[StrictStr], Field(description="Use this optional parameter to paginate through results. Retrieve the `end_cursor` value from the path `data.search_query.combined_results.page_info.end_cursor` in the response.")] = None,
        city_id: Annotated[Optional[StrictStr], Field(description="Numeric ID of a location. You can find this ID using the Search Filters (helper) endpoint at the bottom of the Search section.")] = None,
        education_id: Annotated[Optional[StrictStr], Field(description="Numeric ID of a school. You can find this ID using the Search Filters (helper) endpoint.")] = None,
        work_id: Annotated[Optional[StrictStr], Field(description="Numeric ID of a company. You can find this ID using the Search Filters (helper) endpoint.")] = None,
        disable_bloks: Annotated[Optional[StrictBool], Field(description="Disable Bloks. The default value is `false`.")] = None,
        transform: Annotated[Optional[StrictBool], Field(description="Set to `true` to apply data transformation. The default value is `false`.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Facebook People Search (Proxy)

        This endpoint returns users based on the specified search query and filters like location, education, and work. The search can be paginated using the `end_cursor` parameter.

        :param typed_query: The text query for searching users. (required)
        :type typed_query: str
        :param end_cursor: Use this optional parameter to paginate through results. Retrieve the `end_cursor` value from the path `data.search_query.combined_results.page_info.end_cursor` in the response.
        :type end_cursor: str
        :param city_id: Numeric ID of a location. You can find this ID using the Search Filters (helper) endpoint at the bottom of the Search section.
        :type city_id: str
        :param education_id: Numeric ID of a school. You can find this ID using the Search Filters (helper) endpoint.
        :type education_id: str
        :param work_id: Numeric ID of a company. You can find this ID using the Search Filters (helper) endpoint.
        :type work_id: str
        :param disable_bloks: Disable Bloks. The default value is `false`.
        :type disable_bloks: bool
        :param transform: Set to `true` to apply data transformation. The default value is `false`.
        :type transform: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._facebook_user_search_serialize(
            typed_query=typed_query,
            end_cursor=end_cursor,
            city_id=city_id,
            education_id=education_id,
            work_id=work_id,
            disable_bloks=disable_bloks,
            transform=transform,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VetricFacebookUserSearchResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _facebook_user_search_serialize(
        self,
        typed_query,
        end_cursor,
        city_id,
        education_id,
        work_id,
        disable_bloks,
        transform,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if typed_query is not None:
            
            _query_params.append(('typed_query', typed_query))
            
        if end_cursor is not None:
            
            _query_params.append(('end_cursor', end_cursor))
            
        if city_id is not None:
            
            _query_params.append(('city_id', city_id))
            
        if education_id is not None:
            
            _query_params.append(('education_id', education_id))
            
        if work_id is not None:
            
            _query_params.append(('work_id', work_id))
            
        if disable_bloks is not None:
            
            _query_params.append(('disable_bloks', disable_bloks))
            
        if transform is not None:
            
            _query_params.append(('transform', transform))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/proxy/vetric-facebook/facebook/v1/search/users',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def instagram_location_map(
        self,
        latitude: Annotated[Union[StrictFloat, StrictInt], Field(description="Geographic latitude coordinate in decimal degrees format.")],
        longitude: Annotated[Union[StrictFloat, StrictInt], Field(description="Geographic longitude coordinate in decimal degrees format.")],
        radius: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Search radius in kilometers around the specified latitude and longitude. The default value is 100 km.")] = None,
        category: Annotated[Optional[StrictStr], Field(description="Filter results by category. Accepts 'restaurants', 'cafes', 'sights', 'hotels', 'gardens', or 'bars'.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> VetricInstagramLocationMapResponse:
        """Instagram Location Map (Proxy)

        This endpoint retrieves a list of places centered around a specific geographical coordinate, optionally filtered by category.

        :param latitude: Geographic latitude coordinate in decimal degrees format. (required)
        :type latitude: float
        :param longitude: Geographic longitude coordinate in decimal degrees format. (required)
        :type longitude: float
        :param radius: Search radius in kilometers around the specified latitude and longitude. The default value is 100 km.
        :type radius: float
        :param category: Filter results by category. Accepts 'restaurants', 'cafes', 'sights', 'hotels', 'gardens', or 'bars'.
        :type category: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._instagram_location_map_serialize(
            latitude=latitude,
            longitude=longitude,
            radius=radius,
            category=category,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VetricInstagramLocationMapResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def instagram_location_map_with_http_info(
        self,
        latitude: Annotated[Union[StrictFloat, StrictInt], Field(description="Geographic latitude coordinate in decimal degrees format.")],
        longitude: Annotated[Union[StrictFloat, StrictInt], Field(description="Geographic longitude coordinate in decimal degrees format.")],
        radius: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Search radius in kilometers around the specified latitude and longitude. The default value is 100 km.")] = None,
        category: Annotated[Optional[StrictStr], Field(description="Filter results by category. Accepts 'restaurants', 'cafes', 'sights', 'hotels', 'gardens', or 'bars'.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[VetricInstagramLocationMapResponse]:
        """Instagram Location Map (Proxy)

        This endpoint retrieves a list of places centered around a specific geographical coordinate, optionally filtered by category.

        :param latitude: Geographic latitude coordinate in decimal degrees format. (required)
        :type latitude: float
        :param longitude: Geographic longitude coordinate in decimal degrees format. (required)
        :type longitude: float
        :param radius: Search radius in kilometers around the specified latitude and longitude. The default value is 100 km.
        :type radius: float
        :param category: Filter results by category. Accepts 'restaurants', 'cafes', 'sights', 'hotels', 'gardens', or 'bars'.
        :type category: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._instagram_location_map_serialize(
            latitude=latitude,
            longitude=longitude,
            radius=radius,
            category=category,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VetricInstagramLocationMapResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def instagram_location_map_without_preload_content(
        self,
        latitude: Annotated[Union[StrictFloat, StrictInt], Field(description="Geographic latitude coordinate in decimal degrees format.")],
        longitude: Annotated[Union[StrictFloat, StrictInt], Field(description="Geographic longitude coordinate in decimal degrees format.")],
        radius: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Search radius in kilometers around the specified latitude and longitude. The default value is 100 km.")] = None,
        category: Annotated[Optional[StrictStr], Field(description="Filter results by category. Accepts 'restaurants', 'cafes', 'sights', 'hotels', 'gardens', or 'bars'.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Instagram Location Map (Proxy)

        This endpoint retrieves a list of places centered around a specific geographical coordinate, optionally filtered by category.

        :param latitude: Geographic latitude coordinate in decimal degrees format. (required)
        :type latitude: float
        :param longitude: Geographic longitude coordinate in decimal degrees format. (required)
        :type longitude: float
        :param radius: Search radius in kilometers around the specified latitude and longitude. The default value is 100 km.
        :type radius: float
        :param category: Filter results by category. Accepts 'restaurants', 'cafes', 'sights', 'hotels', 'gardens', or 'bars'.
        :type category: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._instagram_location_map_serialize(
            latitude=latitude,
            longitude=longitude,
            radius=radius,
            category=category,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VetricInstagramLocationMapResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _instagram_location_map_serialize(
        self,
        latitude,
        longitude,
        radius,
        category,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        if radius is not None:
            
            _query_params.append(('radius', radius))
            
        if category is not None:
            
            _query_params.append(('category', category))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/proxy/vetric-instagram/instagram/v1/locations/map',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def instagram_user_search(
        self,
        q: Annotated[StrictStr, Field(description="The text query to search for Instagram users.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> VetricInstagramUserSearchResponse:
        """Instagram People Search (Proxy)

        This endpoint returns Instagram users based on a specified search query.

        :param q: The text query to search for Instagram users. (required)
        :type q: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._instagram_user_search_serialize(
            q=q,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VetricInstagramUserSearchResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def instagram_user_search_with_http_info(
        self,
        q: Annotated[StrictStr, Field(description="The text query to search for Instagram users.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[VetricInstagramUserSearchResponse]:
        """Instagram People Search (Proxy)

        This endpoint returns Instagram users based on a specified search query.

        :param q: The text query to search for Instagram users. (required)
        :type q: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._instagram_user_search_serialize(
            q=q,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VetricInstagramUserSearchResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def instagram_user_search_without_preload_content(
        self,
        q: Annotated[StrictStr, Field(description="The text query to search for Instagram users.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Instagram People Search (Proxy)

        This endpoint returns Instagram users based on a specified search query.

        :param q: The text query to search for Instagram users. (required)
        :type q: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._instagram_user_search_serialize(
            q=q,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VetricInstagramUserSearchResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _instagram_user_search_serialize(
        self,
        q,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if q is not None:
            
            _query_params.append(('q', q))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/proxy/vetric-instagram/instagram/v1/users/search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def linked_in_company_employees(
        self,
        identifier: Annotated[StrictStr, Field(description="The LinkedIn public identifier of the company.")],
        cursor: Annotated[Optional[StrictStr], Field(description="Use this optional parameter to paginate through results. Pass the cursor returned from your previous request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> VetricLinkedInCompanyPeopleResponse:
        """LinkedIn Employee Search (Proxy)

        This endpoint returns the list of employees for a specific company.

        :param identifier: The LinkedIn public identifier of the company. (required)
        :type identifier: str
        :param cursor: Use this optional parameter to paginate through results. Pass the cursor returned from your previous request.
        :type cursor: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._linked_in_company_employees_serialize(
            identifier=identifier,
            cursor=cursor,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VetricLinkedInCompanyPeopleResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def linked_in_company_employees_with_http_info(
        self,
        identifier: Annotated[StrictStr, Field(description="The LinkedIn public identifier of the company.")],
        cursor: Annotated[Optional[StrictStr], Field(description="Use this optional parameter to paginate through results. Pass the cursor returned from your previous request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[VetricLinkedInCompanyPeopleResponse]:
        """LinkedIn Employee Search (Proxy)

        This endpoint returns the list of employees for a specific company.

        :param identifier: The LinkedIn public identifier of the company. (required)
        :type identifier: str
        :param cursor: Use this optional parameter to paginate through results. Pass the cursor returned from your previous request.
        :type cursor: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._linked_in_company_employees_serialize(
            identifier=identifier,
            cursor=cursor,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VetricLinkedInCompanyPeopleResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def linked_in_company_employees_without_preload_content(
        self,
        identifier: Annotated[StrictStr, Field(description="The LinkedIn public identifier of the company.")],
        cursor: Annotated[Optional[StrictStr], Field(description="Use this optional parameter to paginate through results. Pass the cursor returned from your previous request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """LinkedIn Employee Search (Proxy)

        This endpoint returns the list of employees for a specific company.

        :param identifier: The LinkedIn public identifier of the company. (required)
        :type identifier: str
        :param cursor: Use this optional parameter to paginate through results. Pass the cursor returned from your previous request.
        :type cursor: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._linked_in_company_employees_serialize(
            identifier=identifier,
            cursor=cursor,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VetricLinkedInCompanyPeopleResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _linked_in_company_employees_serialize(
        self,
        identifier,
        cursor,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if identifier is not None:
            _path_params['identifier'] = identifier
        # process the query parameters
        if cursor is not None:
            
            _query_params.append(('cursor', cursor))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/proxy/vetric-linkedin/linkedin/v1/company/{identifier}/people',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def linked_in_job_search(
        self,
        keywords: Annotated[StrictStr, Field(description="Keywords you want to search for.")],
        cursor: Annotated[Optional[StrictStr], Field(description="Use this optional parameter to paginate through results. Use the cursor returned from your previous request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> VetricLinkedInJobSearchResponse:
        """LinkedIn Job Search (Proxy)

        This endpoint returns jobs based on the specified search keywords. It searches jobs worldwide and currently does not support filters.

        :param keywords: Keywords you want to search for. (required)
        :type keywords: str
        :param cursor: Use this optional parameter to paginate through results. Use the cursor returned from your previous request.
        :type cursor: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._linked_in_job_search_serialize(
            keywords=keywords,
            cursor=cursor,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VetricLinkedInJobSearchResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def linked_in_job_search_with_http_info(
        self,
        keywords: Annotated[StrictStr, Field(description="Keywords you want to search for.")],
        cursor: Annotated[Optional[StrictStr], Field(description="Use this optional parameter to paginate through results. Use the cursor returned from your previous request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[VetricLinkedInJobSearchResponse]:
        """LinkedIn Job Search (Proxy)

        This endpoint returns jobs based on the specified search keywords. It searches jobs worldwide and currently does not support filters.

        :param keywords: Keywords you want to search for. (required)
        :type keywords: str
        :param cursor: Use this optional parameter to paginate through results. Use the cursor returned from your previous request.
        :type cursor: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._linked_in_job_search_serialize(
            keywords=keywords,
            cursor=cursor,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VetricLinkedInJobSearchResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def linked_in_job_search_without_preload_content(
        self,
        keywords: Annotated[StrictStr, Field(description="Keywords you want to search for.")],
        cursor: Annotated[Optional[StrictStr], Field(description="Use this optional parameter to paginate through results. Use the cursor returned from your previous request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """LinkedIn Job Search (Proxy)

        This endpoint returns jobs based on the specified search keywords. It searches jobs worldwide and currently does not support filters.

        :param keywords: Keywords you want to search for. (required)
        :type keywords: str
        :param cursor: Use this optional parameter to paginate through results. Use the cursor returned from your previous request.
        :type cursor: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._linked_in_job_search_serialize(
            keywords=keywords,
            cursor=cursor,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VetricLinkedInJobSearchResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _linked_in_job_search_serialize(
        self,
        keywords,
        cursor,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if keywords is not None:
            
            _query_params.append(('keywords', keywords))
            
        if cursor is not None:
            
            _query_params.append(('cursor', cursor))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/proxy/vetric-linkedin/linkedin/v1/search/jobs',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def linked_in_people_search(
        self,
        keywords: Annotated[StrictStr, Field(description="Keywords you want to search for.")],
        location_urns: Annotated[Optional[StrictStr], Field(description="Filter by location using either the locations URN or its ID. Multiple locations can be specified, separated by commas.")] = None,
        first_name: Annotated[Optional[StrictStr], Field(description="Filter by first name. Returns results that exactly match the specified first name.")] = None,
        last_name: Annotated[Optional[StrictStr], Field(description="Filter by last name. Returns results that exactly match the specified last name.")] = None,
        title: Annotated[Optional[StrictStr], Field(description="Filter by the current title of the individual. Returns results that exactly match the specified title.")] = None,
        company_name: Annotated[Optional[StrictStr], Field(description="Filter by company name. Returns results that exactly match the specified company name.")] = None,
        current_company: Annotated[Optional[StrictStr], Field(description="Filter by company URN. Returns only profiles of users whose current position is at the specified company URN. Multiple URNs can be specified, separated by commas.")] = None,
        past_company: Annotated[Optional[StrictStr], Field(description="Filter by past company URN. Returns profiles of users who have worked at the specified companies. Multiple URNs can be specified, separated by commas.")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="Use this optional parameter to paginate through results. Use the cursor returned from your previous request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> VetricLinkedInPeopleSearchResponse:
        """LinkedIn People Search (Proxy)

        This endpoint retrieves people based on the specified search keywords, allowing for filtering by location, name, title, and company.

        :param keywords: Keywords you want to search for. (required)
        :type keywords: str
        :param location_urns: Filter by location using either the locations URN or its ID. Multiple locations can be specified, separated by commas.
        :type location_urns: str
        :param first_name: Filter by first name. Returns results that exactly match the specified first name.
        :type first_name: str
        :param last_name: Filter by last name. Returns results that exactly match the specified last name.
        :type last_name: str
        :param title: Filter by the current title of the individual. Returns results that exactly match the specified title.
        :type title: str
        :param company_name: Filter by company name. Returns results that exactly match the specified company name.
        :type company_name: str
        :param current_company: Filter by company URN. Returns only profiles of users whose current position is at the specified company URN. Multiple URNs can be specified, separated by commas.
        :type current_company: str
        :param past_company: Filter by past company URN. Returns profiles of users who have worked at the specified companies. Multiple URNs can be specified, separated by commas.
        :type past_company: str
        :param cursor: Use this optional parameter to paginate through results. Use the cursor returned from your previous request.
        :type cursor: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._linked_in_people_search_serialize(
            keywords=keywords,
            location_urns=location_urns,
            first_name=first_name,
            last_name=last_name,
            title=title,
            company_name=company_name,
            current_company=current_company,
            past_company=past_company,
            cursor=cursor,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VetricLinkedInPeopleSearchResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def linked_in_people_search_with_http_info(
        self,
        keywords: Annotated[StrictStr, Field(description="Keywords you want to search for.")],
        location_urns: Annotated[Optional[StrictStr], Field(description="Filter by location using either the locations URN or its ID. Multiple locations can be specified, separated by commas.")] = None,
        first_name: Annotated[Optional[StrictStr], Field(description="Filter by first name. Returns results that exactly match the specified first name.")] = None,
        last_name: Annotated[Optional[StrictStr], Field(description="Filter by last name. Returns results that exactly match the specified last name.")] = None,
        title: Annotated[Optional[StrictStr], Field(description="Filter by the current title of the individual. Returns results that exactly match the specified title.")] = None,
        company_name: Annotated[Optional[StrictStr], Field(description="Filter by company name. Returns results that exactly match the specified company name.")] = None,
        current_company: Annotated[Optional[StrictStr], Field(description="Filter by company URN. Returns only profiles of users whose current position is at the specified company URN. Multiple URNs can be specified, separated by commas.")] = None,
        past_company: Annotated[Optional[StrictStr], Field(description="Filter by past company URN. Returns profiles of users who have worked at the specified companies. Multiple URNs can be specified, separated by commas.")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="Use this optional parameter to paginate through results. Use the cursor returned from your previous request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[VetricLinkedInPeopleSearchResponse]:
        """LinkedIn People Search (Proxy)

        This endpoint retrieves people based on the specified search keywords, allowing for filtering by location, name, title, and company.

        :param keywords: Keywords you want to search for. (required)
        :type keywords: str
        :param location_urns: Filter by location using either the locations URN or its ID. Multiple locations can be specified, separated by commas.
        :type location_urns: str
        :param first_name: Filter by first name. Returns results that exactly match the specified first name.
        :type first_name: str
        :param last_name: Filter by last name. Returns results that exactly match the specified last name.
        :type last_name: str
        :param title: Filter by the current title of the individual. Returns results that exactly match the specified title.
        :type title: str
        :param company_name: Filter by company name. Returns results that exactly match the specified company name.
        :type company_name: str
        :param current_company: Filter by company URN. Returns only profiles of users whose current position is at the specified company URN. Multiple URNs can be specified, separated by commas.
        :type current_company: str
        :param past_company: Filter by past company URN. Returns profiles of users who have worked at the specified companies. Multiple URNs can be specified, separated by commas.
        :type past_company: str
        :param cursor: Use this optional parameter to paginate through results. Use the cursor returned from your previous request.
        :type cursor: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._linked_in_people_search_serialize(
            keywords=keywords,
            location_urns=location_urns,
            first_name=first_name,
            last_name=last_name,
            title=title,
            company_name=company_name,
            current_company=current_company,
            past_company=past_company,
            cursor=cursor,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VetricLinkedInPeopleSearchResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def linked_in_people_search_without_preload_content(
        self,
        keywords: Annotated[StrictStr, Field(description="Keywords you want to search for.")],
        location_urns: Annotated[Optional[StrictStr], Field(description="Filter by location using either the locations URN or its ID. Multiple locations can be specified, separated by commas.")] = None,
        first_name: Annotated[Optional[StrictStr], Field(description="Filter by first name. Returns results that exactly match the specified first name.")] = None,
        last_name: Annotated[Optional[StrictStr], Field(description="Filter by last name. Returns results that exactly match the specified last name.")] = None,
        title: Annotated[Optional[StrictStr], Field(description="Filter by the current title of the individual. Returns results that exactly match the specified title.")] = None,
        company_name: Annotated[Optional[StrictStr], Field(description="Filter by company name. Returns results that exactly match the specified company name.")] = None,
        current_company: Annotated[Optional[StrictStr], Field(description="Filter by company URN. Returns only profiles of users whose current position is at the specified company URN. Multiple URNs can be specified, separated by commas.")] = None,
        past_company: Annotated[Optional[StrictStr], Field(description="Filter by past company URN. Returns profiles of users who have worked at the specified companies. Multiple URNs can be specified, separated by commas.")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="Use this optional parameter to paginate through results. Use the cursor returned from your previous request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """LinkedIn People Search (Proxy)

        This endpoint retrieves people based on the specified search keywords, allowing for filtering by location, name, title, and company.

        :param keywords: Keywords you want to search for. (required)
        :type keywords: str
        :param location_urns: Filter by location using either the locations URN or its ID. Multiple locations can be specified, separated by commas.
        :type location_urns: str
        :param first_name: Filter by first name. Returns results that exactly match the specified first name.
        :type first_name: str
        :param last_name: Filter by last name. Returns results that exactly match the specified last name.
        :type last_name: str
        :param title: Filter by the current title of the individual. Returns results that exactly match the specified title.
        :type title: str
        :param company_name: Filter by company name. Returns results that exactly match the specified company name.
        :type company_name: str
        :param current_company: Filter by company URN. Returns only profiles of users whose current position is at the specified company URN. Multiple URNs can be specified, separated by commas.
        :type current_company: str
        :param past_company: Filter by past company URN. Returns profiles of users who have worked at the specified companies. Multiple URNs can be specified, separated by commas.
        :type past_company: str
        :param cursor: Use this optional parameter to paginate through results. Use the cursor returned from your previous request.
        :type cursor: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._linked_in_people_search_serialize(
            keywords=keywords,
            location_urns=location_urns,
            first_name=first_name,
            last_name=last_name,
            title=title,
            company_name=company_name,
            current_company=current_company,
            past_company=past_company,
            cursor=cursor,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VetricLinkedInPeopleSearchResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _linked_in_people_search_serialize(
        self,
        keywords,
        location_urns,
        first_name,
        last_name,
        title,
        company_name,
        current_company,
        past_company,
        cursor,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if keywords is not None:
            
            _query_params.append(('keywords', keywords))
            
        if location_urns is not None:
            
            _query_params.append(('locationUrns', location_urns))
            
        if first_name is not None:
            
            _query_params.append(('firstName', first_name))
            
        if last_name is not None:
            
            _query_params.append(('lastName', last_name))
            
        if title is not None:
            
            _query_params.append(('title', title))
            
        if company_name is not None:
            
            _query_params.append(('companyName', company_name))
            
        if current_company is not None:
            
            _query_params.append(('currentCompany', current_company))
            
        if past_company is not None:
            
            _query_params.append(('pastCompany', past_company))
            
        if cursor is not None:
            
            _query_params.append(('cursor', cursor))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/proxy/vetric-linkedin/linkedin/v1/search/people',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def marketplace_search(
        self,
        query: Annotated[StrictStr, Field(description="Latitude of the desired location for better search results.")],
        filter_location_latitude: Annotated[Union[StrictFloat, StrictInt], Field(description="Latitude of the desired location for better search results.")],
        filter_location_longitude: Annotated[Union[StrictFloat, StrictInt], Field(description="Longitude of the desired location for better search results.")],
        end_cursor: Annotated[Optional[StrictStr], Field(description="End cursor value for pagination. Retrieve from path: data.marketplace_search.feed_units.page_info.end_cursor.")] = None,
        virtual_category_id: Annotated[Optional[StrictStr], Field(description="ID representing a category. Example: 139967891347278.")] = None,
        filter_radius_km: Annotated[Optional[Union[Annotated[float, Field(le=200, strict=True, ge=1)], Annotated[int, Field(le=200, strict=True, ge=1)]]], Field(description="Radius for the search in kilometers. Minimum value: 1, Maximum value: 200.")] = None,
        filter_price_upper_bound: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Upper bound for the price filter.")] = None,
        filter_price_lower_bound: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Lower bound for the price filter.")] = None,
        commerce_search_sort_by: Annotated[Optional[StrictStr], Field(description="Sorting method for the search results. Default is 'BEST_MATCH'.")] = None,
        date_listed: Annotated[Optional[StrictStr], Field(description="Filter for date listed. Default is 'ANY'.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> VetricMarketplaceSearchResponse:
        """Facebook Marketplace Search (Proxy)

        The Marketplace search API returns data  from various posts that match the search criteria and specified location

        :param query: Latitude of the desired location for better search results. (required)
        :type query: str
        :param filter_location_latitude: Latitude of the desired location for better search results. (required)
        :type filter_location_latitude: float
        :param filter_location_longitude: Longitude of the desired location for better search results. (required)
        :type filter_location_longitude: float
        :param end_cursor: End cursor value for pagination. Retrieve from path: data.marketplace_search.feed_units.page_info.end_cursor.
        :type end_cursor: str
        :param virtual_category_id: ID representing a category. Example: 139967891347278.
        :type virtual_category_id: str
        :param filter_radius_km: Radius for the search in kilometers. Minimum value: 1, Maximum value: 200.
        :type filter_radius_km: float
        :param filter_price_upper_bound: Upper bound for the price filter.
        :type filter_price_upper_bound: float
        :param filter_price_lower_bound: Lower bound for the price filter.
        :type filter_price_lower_bound: float
        :param commerce_search_sort_by: Sorting method for the search results. Default is 'BEST_MATCH'.
        :type commerce_search_sort_by: str
        :param date_listed: Filter for date listed. Default is 'ANY'.
        :type date_listed: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._marketplace_search_serialize(
            query=query,
            filter_location_latitude=filter_location_latitude,
            filter_location_longitude=filter_location_longitude,
            end_cursor=end_cursor,
            virtual_category_id=virtual_category_id,
            filter_radius_km=filter_radius_km,
            filter_price_upper_bound=filter_price_upper_bound,
            filter_price_lower_bound=filter_price_lower_bound,
            commerce_search_sort_by=commerce_search_sort_by,
            date_listed=date_listed,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VetricMarketplaceSearchResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def marketplace_search_with_http_info(
        self,
        query: Annotated[StrictStr, Field(description="Latitude of the desired location for better search results.")],
        filter_location_latitude: Annotated[Union[StrictFloat, StrictInt], Field(description="Latitude of the desired location for better search results.")],
        filter_location_longitude: Annotated[Union[StrictFloat, StrictInt], Field(description="Longitude of the desired location for better search results.")],
        end_cursor: Annotated[Optional[StrictStr], Field(description="End cursor value for pagination. Retrieve from path: data.marketplace_search.feed_units.page_info.end_cursor.")] = None,
        virtual_category_id: Annotated[Optional[StrictStr], Field(description="ID representing a category. Example: 139967891347278.")] = None,
        filter_radius_km: Annotated[Optional[Union[Annotated[float, Field(le=200, strict=True, ge=1)], Annotated[int, Field(le=200, strict=True, ge=1)]]], Field(description="Radius for the search in kilometers. Minimum value: 1, Maximum value: 200.")] = None,
        filter_price_upper_bound: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Upper bound for the price filter.")] = None,
        filter_price_lower_bound: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Lower bound for the price filter.")] = None,
        commerce_search_sort_by: Annotated[Optional[StrictStr], Field(description="Sorting method for the search results. Default is 'BEST_MATCH'.")] = None,
        date_listed: Annotated[Optional[StrictStr], Field(description="Filter for date listed. Default is 'ANY'.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[VetricMarketplaceSearchResponse]:
        """Facebook Marketplace Search (Proxy)

        The Marketplace search API returns data  from various posts that match the search criteria and specified location

        :param query: Latitude of the desired location for better search results. (required)
        :type query: str
        :param filter_location_latitude: Latitude of the desired location for better search results. (required)
        :type filter_location_latitude: float
        :param filter_location_longitude: Longitude of the desired location for better search results. (required)
        :type filter_location_longitude: float
        :param end_cursor: End cursor value for pagination. Retrieve from path: data.marketplace_search.feed_units.page_info.end_cursor.
        :type end_cursor: str
        :param virtual_category_id: ID representing a category. Example: 139967891347278.
        :type virtual_category_id: str
        :param filter_radius_km: Radius for the search in kilometers. Minimum value: 1, Maximum value: 200.
        :type filter_radius_km: float
        :param filter_price_upper_bound: Upper bound for the price filter.
        :type filter_price_upper_bound: float
        :param filter_price_lower_bound: Lower bound for the price filter.
        :type filter_price_lower_bound: float
        :param commerce_search_sort_by: Sorting method for the search results. Default is 'BEST_MATCH'.
        :type commerce_search_sort_by: str
        :param date_listed: Filter for date listed. Default is 'ANY'.
        :type date_listed: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._marketplace_search_serialize(
            query=query,
            filter_location_latitude=filter_location_latitude,
            filter_location_longitude=filter_location_longitude,
            end_cursor=end_cursor,
            virtual_category_id=virtual_category_id,
            filter_radius_km=filter_radius_km,
            filter_price_upper_bound=filter_price_upper_bound,
            filter_price_lower_bound=filter_price_lower_bound,
            commerce_search_sort_by=commerce_search_sort_by,
            date_listed=date_listed,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VetricMarketplaceSearchResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def marketplace_search_without_preload_content(
        self,
        query: Annotated[StrictStr, Field(description="Latitude of the desired location for better search results.")],
        filter_location_latitude: Annotated[Union[StrictFloat, StrictInt], Field(description="Latitude of the desired location for better search results.")],
        filter_location_longitude: Annotated[Union[StrictFloat, StrictInt], Field(description="Longitude of the desired location for better search results.")],
        end_cursor: Annotated[Optional[StrictStr], Field(description="End cursor value for pagination. Retrieve from path: data.marketplace_search.feed_units.page_info.end_cursor.")] = None,
        virtual_category_id: Annotated[Optional[StrictStr], Field(description="ID representing a category. Example: 139967891347278.")] = None,
        filter_radius_km: Annotated[Optional[Union[Annotated[float, Field(le=200, strict=True, ge=1)], Annotated[int, Field(le=200, strict=True, ge=1)]]], Field(description="Radius for the search in kilometers. Minimum value: 1, Maximum value: 200.")] = None,
        filter_price_upper_bound: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Upper bound for the price filter.")] = None,
        filter_price_lower_bound: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Lower bound for the price filter.")] = None,
        commerce_search_sort_by: Annotated[Optional[StrictStr], Field(description="Sorting method for the search results. Default is 'BEST_MATCH'.")] = None,
        date_listed: Annotated[Optional[StrictStr], Field(description="Filter for date listed. Default is 'ANY'.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Facebook Marketplace Search (Proxy)

        The Marketplace search API returns data  from various posts that match the search criteria and specified location

        :param query: Latitude of the desired location for better search results. (required)
        :type query: str
        :param filter_location_latitude: Latitude of the desired location for better search results. (required)
        :type filter_location_latitude: float
        :param filter_location_longitude: Longitude of the desired location for better search results. (required)
        :type filter_location_longitude: float
        :param end_cursor: End cursor value for pagination. Retrieve from path: data.marketplace_search.feed_units.page_info.end_cursor.
        :type end_cursor: str
        :param virtual_category_id: ID representing a category. Example: 139967891347278.
        :type virtual_category_id: str
        :param filter_radius_km: Radius for the search in kilometers. Minimum value: 1, Maximum value: 200.
        :type filter_radius_km: float
        :param filter_price_upper_bound: Upper bound for the price filter.
        :type filter_price_upper_bound: float
        :param filter_price_lower_bound: Lower bound for the price filter.
        :type filter_price_lower_bound: float
        :param commerce_search_sort_by: Sorting method for the search results. Default is 'BEST_MATCH'.
        :type commerce_search_sort_by: str
        :param date_listed: Filter for date listed. Default is 'ANY'.
        :type date_listed: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._marketplace_search_serialize(
            query=query,
            filter_location_latitude=filter_location_latitude,
            filter_location_longitude=filter_location_longitude,
            end_cursor=end_cursor,
            virtual_category_id=virtual_category_id,
            filter_radius_km=filter_radius_km,
            filter_price_upper_bound=filter_price_upper_bound,
            filter_price_lower_bound=filter_price_lower_bound,
            commerce_search_sort_by=commerce_search_sort_by,
            date_listed=date_listed,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VetricMarketplaceSearchResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _marketplace_search_serialize(
        self,
        query,
        filter_location_latitude,
        filter_location_longitude,
        end_cursor,
        virtual_category_id,
        filter_radius_km,
        filter_price_upper_bound,
        filter_price_lower_bound,
        commerce_search_sort_by,
        date_listed,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if query is not None:
            
            _query_params.append(('query', query))
            
        if filter_location_latitude is not None:
            
            _query_params.append(('filter_location_latitude', filter_location_latitude))
            
        if filter_location_longitude is not None:
            
            _query_params.append(('filter_location_longitude', filter_location_longitude))
            
        if end_cursor is not None:
            
            _query_params.append(('end_cursor', end_cursor))
            
        if virtual_category_id is not None:
            
            _query_params.append(('virtual_category_id', virtual_category_id))
            
        if filter_radius_km is not None:
            
            _query_params.append(('filter_radius_km', filter_radius_km))
            
        if filter_price_upper_bound is not None:
            
            _query_params.append(('filter_price_upper_bound', filter_price_upper_bound))
            
        if filter_price_lower_bound is not None:
            
            _query_params.append(('filter_price_lower_bound', filter_price_lower_bound))
            
        if commerce_search_sort_by is not None:
            
            _query_params.append(('commerce_search_sort_by', commerce_search_sort_by))
            
        if date_listed is not None:
            
            _query_params.append(('date_listed', date_listed))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/proxy/vetric-facebook/facebook/v1/marketplace/search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def top_search_results(
        self,
        query: Annotated[StrictStr, Field(description="The search term you wish to find popular results for.")],
        cursor: Annotated[Optional[StrictStr], Field(description="This optional parameter points to the starting point of your search. If this is your first request, this parameter can be omitted. In subsequent requests, use the cursor returned by the previous request to paginate through results.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> VetricTwitterTopSearchResponse:
        """Twitter Top Tweets (Proxy)

        This endpoint retrieves the top results for a given query, making it ideal for finding the most popular tweets related to a specific keyword or topic.

        :param query: The search term you wish to find popular results for. (required)
        :type query: str
        :param cursor: This optional parameter points to the starting point of your search. If this is your first request, this parameter can be omitted. In subsequent requests, use the cursor returned by the previous request to paginate through results.
        :type cursor: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._top_search_results_serialize(
            query=query,
            cursor=cursor,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VetricTwitterTopSearchResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def top_search_results_with_http_info(
        self,
        query: Annotated[StrictStr, Field(description="The search term you wish to find popular results for.")],
        cursor: Annotated[Optional[StrictStr], Field(description="This optional parameter points to the starting point of your search. If this is your first request, this parameter can be omitted. In subsequent requests, use the cursor returned by the previous request to paginate through results.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[VetricTwitterTopSearchResponse]:
        """Twitter Top Tweets (Proxy)

        This endpoint retrieves the top results for a given query, making it ideal for finding the most popular tweets related to a specific keyword or topic.

        :param query: The search term you wish to find popular results for. (required)
        :type query: str
        :param cursor: This optional parameter points to the starting point of your search. If this is your first request, this parameter can be omitted. In subsequent requests, use the cursor returned by the previous request to paginate through results.
        :type cursor: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._top_search_results_serialize(
            query=query,
            cursor=cursor,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VetricTwitterTopSearchResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def top_search_results_without_preload_content(
        self,
        query: Annotated[StrictStr, Field(description="The search term you wish to find popular results for.")],
        cursor: Annotated[Optional[StrictStr], Field(description="This optional parameter points to the starting point of your search. If this is your first request, this parameter can be omitted. In subsequent requests, use the cursor returned by the previous request to paginate through results.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Twitter Top Tweets (Proxy)

        This endpoint retrieves the top results for a given query, making it ideal for finding the most popular tweets related to a specific keyword or topic.

        :param query: The search term you wish to find popular results for. (required)
        :type query: str
        :param cursor: This optional parameter points to the starting point of your search. If this is your first request, this parameter can be omitted. In subsequent requests, use the cursor returned by the previous request to paginate through results.
        :type cursor: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._top_search_results_serialize(
            query=query,
            cursor=cursor,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VetricTwitterTopSearchResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _top_search_results_serialize(
        self,
        query,
        cursor,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if query is not None:
            
            _query_params.append(('query', query))
            
        if cursor is not None:
            
            _query_params.append(('cursor', cursor))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/proxy/vetric-twitter/twitter/v1/search/top',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


