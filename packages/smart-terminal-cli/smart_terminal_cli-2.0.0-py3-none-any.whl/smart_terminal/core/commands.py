"""
Command Generation and Execution Module for SmartTerminal.

This module handles generating terminal commands from natural language using AI
and executing those commands with proper user input handling.
"""

import os
import sys
import logging
import subprocess
from typing import List, Dict, Any, Tuple, Optional

from smart_terminal.core.ai import AIClient
from smart_terminal.utils.colors import Colors
from smart_terminal.core.base import CommandProcessor
from smart_terminal.exceptions import CommandError, AIError

# Import models if available
try:
    from smart_terminal.models.command import Command, CommandResult

    MODELS_AVAILABLE = True
except ImportError:
    MODELS_AVAILABLE = False

# Setup logging
logger = logging.getLogger(__name__)


class CommandGenerator:
    """
    Generates terminal commands from natural language using AI.

    This class handles the interaction with the AI to convert
    natural language requests into executable terminal commands.
    """

    def __init__(self, ai_client: AIClient):
        """
        Initialize command generator with AI client.

        Args:
            ai_client: AI client for API calls
        """
        self.ai_client = ai_client

    async def generate_commands(
        self, user_query: str, context: Optional[Dict[str, Any]] = None
    ) -> List[Dict[str, Any]]:
        """
        Generate a sequence of commands from a natural language query.

        Args:
            user_query: Natural language query from user
            context: Optional context information for better command generation

        Returns:
            List of command sets generated by the AI

        Raises:
            AIError: If command generation fails
        """
        # Create context if not provided
        if context is None:
            context = {}

        try:
            logger.debug(f"Generating commands for query: {user_query}")

            # Generate commands using AI client
            commands = await self.ai_client.generate_commands(
                user_query, context=context
            )

            if not commands:
                logger.debug("No commands generated")
                return []

            logger.debug(f"Generated {len(commands)} commands")
            return commands

        except AIError:
            # Re-raise AIError since it's already properly formatted
            raise
        except Exception as e:
            raise AIError(f"Failed to generate commands: {e}")


class CommandExecutor(CommandProcessor):
    """
    Executes terminal commands with proper user input handling.

    This class handles executing generated commands, including
    placeholder replacement and sudo handling.
    """

    def __init__(self, dry_run: bool = False):
        """
        Initialize command executor.

        Args:
            dry_run: Whether to only show commands without executing them
        """
        self.dry_run = dry_run

    def execute_command(
        self, command: str, requires_admin: bool = False
    ) -> Tuple[bool, str]:
        """
        Execute a shell command and return the output.

        Args:
            command: Command to execute
            requires_admin: Whether the command requires admin privileges

        Returns:
            Tuple of (success, output/error message)

        Raises:
            CommandError: If the command execution fails
        """
        try:
            logger.debug(
                f"Executing command: {command}, requires_admin={requires_admin}"
            )

            # If in dry run mode, just return success without executing
            if self.dry_run:
                return True, f"[DRY RUN] Would execute: {command}"

            # Add sudo if needed and not on Windows
            if requires_admin and sys.platform != "win32":
                command = f"sudo {command}"

            # Execute the command
            result = subprocess.run(command, shell=True, capture_output=True, text=True)

            if result.returncode == 0:
                logger.debug("Command executed successfully")
                return True, result.stdout
            else:
                return False, result.stderr

        except Exception as e:
            raise CommandError(f"Command execution failed: {e}", command=command)

    def prompt_for_input(self, input_name: str) -> str:
        """
        Prompt the user for input for a command parameter.

        Args:
            input_name: Name of the parameter

        Returns:
            str: User-provided value
        """
        if input_name.lower() == "sudo":
            return "sudo"  # Just return the sudo command itself

        value = input(f"Enter value for {Colors.highlight(input_name)}: ")
        return value

    def replace_placeholders(self, command: str, user_inputs: List[str]) -> str:
        """
        Replace placeholders in a command with actual user inputs.

        Args:
            command: Command with placeholders
            user_inputs: List of input parameter names

        Returns:
            Command with placeholders replaced with actual values
        """
        logger.debug(f"Replacing placeholders in command: {command}")
        logger.debug(f"User inputs: {user_inputs}")

        # Create a copy of the original command
        final_command = command

        # Replace placeholders that match user_inputs
        for input_name in user_inputs:
            if input_name.lower() == "sudo":
                # Skip sudo as we handle it separately
                continue

            value = self.prompt_for_input(input_name)
            placeholder = f"<{input_name}>"

            # Replace the placeholder with the actual value
            final_command = final_command.replace(placeholder, value)
            logger.debug(f"Replaced '{placeholder}' with '{value}'")

        # Check for any remaining placeholders
        while "<" in final_command and ">" in final_command:
            start_idx = final_command.find("<")
            end_idx = final_command.find(">", start_idx)

            if start_idx != -1 and end_idx != -1:
                placeholder = final_command[start_idx : end_idx + 1]
                placeholder_name = placeholder[1:-1]  # Remove < and >
                logger.debug(f"Found additional placeholder: {placeholder}")

                # Ask for value for this placeholder
                value = self.prompt_for_input(placeholder_name)

                # Replace the placeholder
                final_command = final_command.replace(placeholder, value)
                logger.debug(f"Replaced '{placeholder}' with '{value}'")
            else:
                # No more valid placeholders found, break the loop
                break

        logger.debug(f"Final command after replacement: {final_command}")
        return final_command

    def process_commands(self, commands: List[Dict[str, Any]]) -> bool:
        """
        Process and execute a list of commands.

        Args:
            commands: List of command data dictionaries

        Returns:
            bool: True if all commands were executed successfully, False otherwise
        """
        # Initialize success flag
        success = True

        # Convert to Command objects if models are available
        cmd_objects = []
        if MODELS_AVAILABLE:
            for cmd_dict in commands:
                cmd_objects.append(Command(**cmd_dict))

        # Process each command
        for i, cmd_dict in enumerate(commands):
            cmd = cmd_objects[i] if MODELS_AVAILABLE else cmd_dict

            # Extract command details
            if MODELS_AVAILABLE:
                command_str = cmd.command
                user_inputs = cmd.user_inputs
                requires_admin = cmd.requires_admin
                description = cmd.description or ""
                os_type = cmd.os
            else:
                command_str = cmd.get("command", "")
                user_inputs = cmd.get("user_inputs", [])
                requires_admin = (
                    cmd.get("requires_admin", False) or "sudo" in user_inputs
                )
                description = cmd.get("description", "")
                os_type = cmd.get("os", "")

            print(
                f"\n{Colors.highlight(f'Command {i + 1}:')} {Colors.cmd(command_str)}"
            )
            print(f"{Colors.highlight('Description:')} {description}")

            if os_type:
                print(f"{Colors.highlight('OS:')} {os_type}")

            # Check if user wants to execute this command
            confirmation = input(
                Colors.warning("Execute this command? (y/n): ")
            ).lower()
            if confirmation != "y":
                print(Colors.info("Command skipped."))
                continue

            # Replace placeholders and execute
            final_command = self.replace_placeholders(command_str, user_inputs)
            print(Colors.info(f"Executing: {Colors.cmd(final_command)}"))

            try:
                success_cmd, output = self.execute_command(
                    final_command, requires_admin
                )
                success = success and success_cmd

                if success_cmd:
                    print(Colors.success("Command executed successfully:"))
                    if output.strip():  # Only print output if it's not empty
                        print(output)

                    # Show current directory after execution (especially for cd commands)
                    current_dir = os.getcwd()
                    username = os.environ.get(
                        "USER", os.environ.get("USERNAME", "user")
                    )
                    hostname = os.environ.get(
                        "HOSTNAME", os.environ.get("COMPUTERNAME", "localhost")
                    )
                    print(f"\n{Colors.info(f'{username}@{hostname} {current_dir} % ')}")
                else:
                    print(Colors.error("Command failed:"))
                    print(output)
            except CommandError as e:
                success = False
                print(Colors.error(f"Error: {e}"))

        return success
