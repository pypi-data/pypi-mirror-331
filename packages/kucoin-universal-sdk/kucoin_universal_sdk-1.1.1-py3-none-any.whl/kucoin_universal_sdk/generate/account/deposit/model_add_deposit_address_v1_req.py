# coding: utf-8

# Code generated by Kucoin Universal SDK Generator; DO NOT EDIT.

from __future__ import annotations
import pprint
import json

from pydantic import BaseModel, ConfigDict, Field
from typing import Any, ClassVar, Dict, List, Optional


class AddDepositAddressV1Req(BaseModel):
    """
    AddDepositAddressV1Req

    Attributes:
        currency (str): currency
        chain (str): The chainId of currency, e.g. The available value for USDT are OMNI, ERC20, TRC20, default is ERC20. The available value for BTC are Native, Segwit, TRC20, the parameters are bech32, btc, trx, default is Native. This only apply for multi-chain currency, and there is no need for single chain currency.
    """

    currency: Optional[str] = Field(default=None, description="currency")
    chain: Optional[str] = Field(
        default='eth',
        description=
        "The chainId of currency, e.g. The available value for USDT are OMNI, ERC20, TRC20, default is ERC20. The available value for BTC are Native, Segwit, TRC20, the parameters are bech32, btc, trx, default is Native. This only apply for multi-chain currency, and there is no need for single chain currency."
    )

    __properties: ClassVar[List[str]] = ["currency", "chain"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=False,
        protected_namespaces=(),
    )

    def to_str(self) -> str:
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        return self.model_dump_json(by_alias=True, exclude_none=True)

    @classmethod
    def from_json(cls, json_str: str) -> Optional[AddDepositAddressV1Req]:
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        _dict = self.model_dump(
            by_alias=True,
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(
            cls, obj: Optional[Dict[str,
                                    Any]]) -> Optional[AddDepositAddressV1Req]:
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "currency":
            obj.get("currency"),
            "chain":
            obj.get("chain") if obj.get("chain") is not None else 'eth'
        })
        return _obj


class AddDepositAddressV1ReqBuilder:

    def __init__(self):
        self.obj = {}

    def set_currency(self, value: str) -> AddDepositAddressV1ReqBuilder:
        """
        currency
        """
        self.obj['currency'] = value
        return self

    def set_chain(self, value: str) -> AddDepositAddressV1ReqBuilder:
        """
        The chainId of currency, e.g. The available value for USDT are OMNI, ERC20, TRC20, default is ERC20. The available value for BTC are Native, Segwit, TRC20, the parameters are bech32, btc, trx, default is Native. This only apply for multi-chain currency, and there is no need for single chain currency.
        """
        self.obj['chain'] = value
        return self

    def build(self) -> AddDepositAddressV1Req:
        return AddDepositAddressV1Req(**self.obj)
