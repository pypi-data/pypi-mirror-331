# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.3.0
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

"""peak_afl (Auto Feature Library) is an object-oriented library that provides functionality for auto features."""


from typing import Any, Sequence
from ids_peak_ipl.ids_peak_ipl import Image, Gain



from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _ids_peak_afl_python_interface
else:
    import _ids_peak_afl_python_interface

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_afl_python_interface.delete_SwigPyIterator

    def value(self) -> "Any":
        return _ids_peak_afl_python_interface.SwigPyIterator_value(self)

    def incr(self, n: "int"=1) -> "SwigPyIterator":
        return _ids_peak_afl_python_interface.SwigPyIterator_incr(self, n)

    def decr(self, n: "int"=1) -> "SwigPyIterator":
        return _ids_peak_afl_python_interface.SwigPyIterator_decr(self, n)

    def distance(self, x: "SwigPyIterator") -> "int":
        return _ids_peak_afl_python_interface.SwigPyIterator_distance(self, x)

    def equal(self, x: "SwigPyIterator") -> "bool":
        return _ids_peak_afl_python_interface.SwigPyIterator_equal(self, x)

    def copy(self) -> "SwigPyIterator":
        return _ids_peak_afl_python_interface.SwigPyIterator_copy(self)

    def next(self) -> "Any":
        return _ids_peak_afl_python_interface.SwigPyIterator_next(self)

    def __next__(self) -> "Any":
        return _ids_peak_afl_python_interface.SwigPyIterator___next__(self)

    def previous(self) -> "Any":
        return _ids_peak_afl_python_interface.SwigPyIterator_previous(self)

    def advance(self, n: "int") -> "SwigPyIterator":
        return _ids_peak_afl_python_interface.SwigPyIterator_advance(self, n)

    def __eq__(self, x: "SwigPyIterator") -> "bool":
        return _ids_peak_afl_python_interface.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: "SwigPyIterator") -> "bool":
        return _ids_peak_afl_python_interface.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: "int") -> "SwigPyIterator":
        return _ids_peak_afl_python_interface.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: "int") -> "SwigPyIterator":
        return _ids_peak_afl_python_interface.SwigPyIterator___isub__(self, n)

    def __add__(self, n: "int") -> "SwigPyIterator":
        return _ids_peak_afl_python_interface.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "int":
        return _ids_peak_afl_python_interface.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _ids_peak_afl_python_interface:
_ids_peak_afl_python_interface.SwigPyIterator_swigregister(SwigPyIterator)
SHARED_PTR_DISOWN = _ids_peak_afl_python_interface.SHARED_PTR_DISOWN
class AutoAverages(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2: "int", arg3: "int", v1: "int"):
        _ids_peak_afl_python_interface.AutoAverages_swiginit(self, _ids_peak_afl_python_interface.new_AutoAverages(arg2, arg3, v1))

    def get0(self) -> "int":
        return _ids_peak_afl_python_interface.AutoAverages_get0(self)

    def get1(self) -> "int":
        return _ids_peak_afl_python_interface.AutoAverages_get1(self)

    def get2(self) -> "int":
        return _ids_peak_afl_python_interface.AutoAverages_get2(self)

    def set0(self, val: "int") -> "None":
        return _ids_peak_afl_python_interface.AutoAverages_set0(self, val)

    def set1(self, val: "int") -> "None":
        return _ids_peak_afl_python_interface.AutoAverages_set1(self, val)

    def set2(self, val: "int") -> "None":
        return _ids_peak_afl_python_interface.AutoAverages_set2(self, val)

    def __len__(self) -> "int":
        return _ids_peak_afl_python_interface.AutoAverages___len__(self)

    def __getitem__(self, n):
        if n >= len(self):
            raise IndexError()
        return getattr(self, 'get%d' % n)()
    def __setitem__(self, n, val):
        if n >= len(self):
            raise IndexError()
        getattr(self, 'set%d' % n)(val)

    __swig_destroy__ = _ids_peak_afl_python_interface.delete_AutoAverages

# Register AutoAverages in _ids_peak_afl_python_interface:
_ids_peak_afl_python_interface.AutoAverages_swigregister(AutoAverages)
class Library(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def Init() -> "None":
        return _ids_peak_afl_python_interface.Library_Init()

    @staticmethod
    def Exit() -> "None":
        return _ids_peak_afl_python_interface.Library_Exit()

    @staticmethod
    def GetLastError() -> "str":
        return _ids_peak_afl_python_interface.Library_GetLastError()

    @staticmethod
    def Version() -> "Version_t":
        return _ids_peak_afl_python_interface.Library_Version()

    def __init__(self):
        _ids_peak_afl_python_interface.Library_swiginit(self, _ids_peak_afl_python_interface.new_Library())
    __swig_destroy__ = _ids_peak_afl_python_interface.delete_Library

# Register Library in _ids_peak_afl_python_interface:
_ids_peak_afl_python_interface.Library_swigregister(Library)
class FinishedCallback(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, controller: "Controller"):
        if self.__class__ == FinishedCallback:
            _self = None
        else:
            _self = self
        _ids_peak_afl_python_interface.FinishedCallback_swiginit(self, _ids_peak_afl_python_interface.new_FinishedCallback(_self, controller))
    __swig_destroy__ = _ids_peak_afl_python_interface.delete_FinishedCallback

    def callback(self) -> "None":
        return _ids_peak_afl_python_interface.FinishedCallback_callback(self)
    def __disown__(self):
        self.this.disown()
        _ids_peak_afl_python_interface.disown_FinishedCallback(self)
        return weakref.proxy(self)

# Register FinishedCallback in _ids_peak_afl_python_interface:
_ids_peak_afl_python_interface.FinishedCallback_swigregister(FinishedCallback)
class ProcessDataCallback(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, controller: "Controller"):
        if self.__class__ == ProcessDataCallback:
            _self = None
        else:
            _self = self
        _ids_peak_afl_python_interface.ProcessDataCallback_swiginit(self, _ids_peak_afl_python_interface.new_ProcessDataCallback(_self, controller))
    __swig_destroy__ = _ids_peak_afl_python_interface.delete_ProcessDataCallback

    def callback(self, arg0: "int", arg1: "int") -> "None":
        return _ids_peak_afl_python_interface.ProcessDataCallback_callback(self, arg0, arg1)
    def __disown__(self):
        self.this.disown()
        _ids_peak_afl_python_interface.disown_ProcessDataCallback(self)
        return weakref.proxy(self)

# Register ProcessDataCallback in _ids_peak_afl_python_interface:
_ids_peak_afl_python_interface.ProcessDataCallback_swigregister(ProcessDataCallback)
class ComponentExposureFinishedCallback(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, controller: "Controller"):
        if self.__class__ == ComponentExposureFinishedCallback:
            _self = None
        else:
            _self = self
        _ids_peak_afl_python_interface.ComponentExposureFinishedCallback_swiginit(self, _ids_peak_afl_python_interface.new_ComponentExposureFinishedCallback(_self, controller))
    __swig_destroy__ = _ids_peak_afl_python_interface.delete_ComponentExposureFinishedCallback

    def callback(self) -> "None":
        return _ids_peak_afl_python_interface.ComponentExposureFinishedCallback_callback(self)
    def __disown__(self):
        self.this.disown()
        _ids_peak_afl_python_interface.disown_ComponentExposureFinishedCallback(self)
        return weakref.proxy(self)

# Register ComponentExposureFinishedCallback in _ids_peak_afl_python_interface:
_ids_peak_afl_python_interface.ComponentExposureFinishedCallback_swigregister(ComponentExposureFinishedCallback)
class ComponentGainFinishedCallback(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, controller: "Controller"):
        if self.__class__ == ComponentGainFinishedCallback:
            _self = None
        else:
            _self = self
        _ids_peak_afl_python_interface.ComponentGainFinishedCallback_swiginit(self, _ids_peak_afl_python_interface.new_ComponentGainFinishedCallback(_self, controller))
    __swig_destroy__ = _ids_peak_afl_python_interface.delete_ComponentGainFinishedCallback

    def callback(self) -> "None":
        return _ids_peak_afl_python_interface.ComponentGainFinishedCallback_callback(self)
    def __disown__(self):
        self.this.disown()
        _ids_peak_afl_python_interface.disown_ComponentGainFinishedCallback(self)
        return weakref.proxy(self)

# Register ComponentGainFinishedCallback in _ids_peak_afl_python_interface:
_ids_peak_afl_python_interface.ComponentGainFinishedCallback_swigregister(ComponentGainFinishedCallback)
class Version_t(object):
    r"""Version information for ids_peak_afl"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    major: "int" = property(_ids_peak_afl_python_interface.Version_t_major_get, _ids_peak_afl_python_interface.Version_t_major_set)
    minor: "int" = property(_ids_peak_afl_python_interface.Version_t_minor_get, _ids_peak_afl_python_interface.Version_t_minor_set, doc=r"""Major""")
    subminor: "int" = property(_ids_peak_afl_python_interface.Version_t_subminor_get, _ids_peak_afl_python_interface.Version_t_subminor_set, doc=r"""Minor""")
    patch: "int" = property(_ids_peak_afl_python_interface.Version_t_patch_get, _ids_peak_afl_python_interface.Version_t_patch_set, doc=r"""Subminor""")

    def ToString(self) -> "str":
        r"""
         Patch
        The String representation for the ids_peak_afl version
        :rtype: str
        :return: the str representation
        """
        return _ids_peak_afl_python_interface.Version_t_ToString(self)

    def Major(self) -> "int":
        r"""
        Returns the major part of the version which is the first part of the version scheme separated by dots.

        :rtype: int
        :return: **a**.b.c.d
        """
        return _ids_peak_afl_python_interface.Version_t_Major(self)

    def Minor(self) -> "int":
        r"""
        Returns the minor part of the version which is the second part of the version scheme separated by dots.

        :rtype: int
        :return: a.**b**.c.d
        """
        return _ids_peak_afl_python_interface.Version_t_Minor(self)

    def Subminor(self) -> "int":
        r"""
        Returns the subminor part of the version which is the third part of the version scheme separated by dots.

        :rtype: int
        :return: a.b.**c**.d
        """
        return _ids_peak_afl_python_interface.Version_t_Subminor(self)

    def Patch(self) -> "int":
        r"""
        Returns the patch part of the version which is the fourth part of the version scheme separated by dots.

        :rtype: int
        :return: a.b.c.**d**
        """
        return _ids_peak_afl_python_interface.Version_t_Patch(self)

    def __str__(self):
        return self.ToString()


    def __init__(self):
        _ids_peak_afl_python_interface.Version_t_swiginit(self, _ids_peak_afl_python_interface.new_Version_t())
    __swig_destroy__ = _ids_peak_afl_python_interface.delete_Version_t

# Register Version_t in _ids_peak_afl_python_interface:
_ids_peak_afl_python_interface.Version_t_swigregister(Version_t)
class Exception(Exception):
    r"""General Error type"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def what(self) -> "str":
        r"""
        Get the str representation for the exception

        :rtype: str
        :return: the str explaining the exception

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Exception_what(self)

    def __init__(self, *args):
        _ids_peak_afl_python_interface.Exception_swiginit(self, _ids_peak_afl_python_interface.new_Exception(*args))
    __swig_destroy__ = _ids_peak_afl_python_interface.delete_Exception

# Register Exception in _ids_peak_afl_python_interface:
_ids_peak_afl_python_interface.Exception_swigregister(Exception)
class Manager(object):
    r"""The autofeature manager"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_afl_python_interface.delete_Manager

    def __init__(self, *args):
        r"""
        Create an automanager instance

        Creates an automanager instance.

        :type node_map: NodeMap, in
        :param node_map: the shared pointer to the device nodemap

        :raises: Exception if an error occurs. Check code() and what() for an explanation of the error

        Since: 1.1
        """
        _ids_peak_afl_python_interface.Manager_swiginit(self, _ids_peak_afl_python_interface.new_Manager(*args))

    def AddController(self, controller: "Controller") -> "None":
        r"""
        Add a controller to an automanager

        An autocontroller instance can only be added to one autofeature manager at the same time.
        The same type can only be added one time.

        :type controller: :py:class:`Controller`, in
        :param controller: shared_ptr to a controller

        :raises: Exception if an error occurs. Check code() and what() for an explanation of the error

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Manager_AddController(self, controller)

    def RemoveController(self, controller: "Controller") -> "None":
        r"""
        Remove a controller from an automanager

        Remove a controller from a manager.
        For a function which destroys the object in one call, see #peak_afl_AutoFeatureManager_DestroyController.

        :type controller: :py:class:`Controller`, in
        :param controller: shared_ptr to a controller

        :raises: Exception if an error occurs. Check code() and what() for an explanation of the error

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Manager_RemoveController(self, controller)

    def Process(self, image: "Image") -> "None":
        r"""
        Process an image

        Processes an image.

        :type image: Image, in
        :param image: an Image image

        :raises: Exception if an error occurs. Check code() and what() for an explanation of the error

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Manager_Process(self, image)

    def CreateController(self, type: "peak_afl_controllerType") -> "Controller":
        r"""
        Create a controller and append it to Manager

        Convenience function to create an autofeature controller and add it to the manager.
        The same type can only be added one time.

        :type type: int, in
        :param type: controller type, see #peak_afl_controllerType

        :rtype: :py:class:`Controller`
        :return: the shared ptr to the created controller

        :raises: Exception if deinitialization fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Manager_CreateController(self, type)

    def DestroyAllController(self) -> "None":
        r"""
        Destroy all controllers for a manager.

        After this operation all controllers associated with the given manager will be invalid.

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Manager_DestroyAllController(self)

    def DestroyController(self, controller: "Controller") -> "None":
        r"""
        Destroy a controller.

        After this operation the controller will be invalid.

        :type controller: :py:class:`Controller`, in
        :param controller: shared ptr to a controller

        :raises: Exception if function fails
        """
        return _ids_peak_afl_python_interface.Manager_DestroyController(self, controller)

    def SetGainIPL(self, gain: "Gain") -> "None":
        r"""
        Sets the ipl gain.

        :type gain: Gain, in
        :param gain: an Gain gain

        :raises: Exception if function fails

        Since: 1.2
        """
        return _ids_peak_afl_python_interface.Manager_SetGainIPL(self, gain)

    def Status(self) -> "bool":
        r"""
        Get the status of a manager.

        The returned value will contain whether the manager currently processes an image (true) or is idle (false).

        :rtype: boolean
        :return: manager status

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Manager_Status(self)

    def ControllerList(self) -> "Sequence[Controller]":
        r"""
        Get the list of the controller associated with the manager

        :rtype: Sequence[Controller]
        :return: controller list

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Manager_ControllerList(self)

    def ControllerCount(self) -> "int":
        r"""
        Get the list count of the controller associated with the manager

        :rtype: int
        :return: number of controllers in list

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Manager_ControllerCount(self)

    def GetController(self, type: "peak_afl_controllerType") -> "Controller":
        r"""
        Get the controller for a type

        :type type: int, in
        :param type: controller type.

        :rtype: :py:class:`Controller`
        :return: number of controllers in list

        :raises: Exception if no controller is found

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Manager_GetController(self, type)

# Register Manager in _ids_peak_afl_python_interface:
_ids_peak_afl_python_interface.Manager_swigregister(Manager)
class Controller(object):
    r"""The Controller class"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_afl_python_interface.delete_Controller

    @staticmethod
    def Create(type: "peak_afl_controllerType") -> "Controller":
        r"""
        Create a new controller

        :type type: int, in
        :param type: controller type

        :rtype: :py:class:`Controller`
        :return: the shared ptr to the created controller

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_Create(type)

    def IsSkipFramesSupported(self) -> "bool":
        r"""
        Check if skip frames is supported for a controller.

        :rtype: boolean
        :return: boolean if controller supports skipping frames

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_IsSkipFramesSupported(self)

    def SetSkipFrames(self, count: "int") -> "None":
        r"""
        Set number of frames skipped for a controller.

        Sets the skipped frames for the controller. Only every N-th image will be processed.

        :type count: int, in
        :param count:      number of frames skipped

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_SetSkipFrames(self, count)

    def GetSkipFrames(self) -> "int":
        r"""
        Get number of frames skipped for a controller.

        Gets the skipped frames for the controller. Only every N-th image will be processed.

        :rtype: int
        :return: number of frames skipped

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_GetSkipFrames(self)

    def GetSkipFramesRange(self) -> "IntRange":
        r"""
        Get range for frames skipped for a controller.

        :rtype: Range< int >
        :return: valid Range for frames skipped

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_GetSkipFramesRange(self)

    def IsROISupported(self) -> "bool":
        r"""
        Check if setting a region of interest is supported for a controller.

        If true region of interest is supported, otherwise it is unsupported.

        :rtype: boolean
        :return: boolean if controller supports setting a region of interest

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_IsROISupported(self)

    def SetROI(self, rect: "peak_afl_rectangle") -> "None":
        r"""
        Set the autofeature region of interest for a controller.

        Set the region of interest for a controller. The processed image will be cropped to the region of interest set.

        :type rect: :py:class:`peak_afl_rectangle`, in
        :param rect:        region of interest

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_SetROI(self, rect)

    def GetROI(self) -> "peak_afl_rectangle":
        r"""
        Get the autofeature region of interest for a controller.

        Get the region of interest for a controller. The processed image will be cropped to the region of interest set.

        :rtype: :py:class:`peak_afl_rectangle`
        :return: region of interest

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_GetROI(self)

    def IsROIPresetSupported(self) -> "bool":
        r"""
        Check if ROI preset is supported for a controller.

        true if ROI preset is supported, otherwise it is unsupported.

        :rtype: boolean
        :return: boolean if controller supports ROI preset

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_IsROIPresetSupported(self)

    def SetROIPreset(self, preset: "peak_afl_roi_preset") -> "None":
        r"""
        Set the autofeature region of interest preset for a controller.

        Will set the supplied preset as region of interest. See also #SetROI.

        :type preset: int, in
        :param preset:  region of interest preset

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_SetROIPreset(self, preset)

    def IsModeSupported(self) -> "bool":
        r"""
        Check if auto mode is supported for a controller.

        true if auto mode is supported, otherwise it is unsupported.

        :rtype: boolean
        :return: boolean if controller supports auto mode

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_IsModeSupported(self)

    def SetMode(self, mode: "peak_afl_controller_automode") -> "None":
        r"""
        Set the autofeature mode for a controller.

        Will set the controller mode to mode. See #peak_afl_controller_automode for a list of valid values.

        :type mode: int, in
        :param mode:       autofeature mode

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_SetMode(self, mode)

    def GetMode(self) -> "peak_afl_controller_automode":
        r"""
        Get the current autofeature mode for a controller.

        :rtype: int
        :return: autofeature mode

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_GetMode(self)

    def IsBrightnessAlgorithmSupported(self) -> "bool":
        r"""
        Check if auto brightness algorithm is supported for a controller.

        true if auto brightness algorithm is supported, otherwise it is unsupported.

        :rtype: boolean
        :return: boolean if controller supports auto brightness algorithm

        :raises: Exception if function fails

        Since: 1.6
        """
        return _ids_peak_afl_python_interface.Controller_IsBrightnessAlgorithmSupported(self)

    def SetBrightnessAlgorithm(self, algorithm: "peak_afl_controller_brightness_algorithm") -> "None":
        r"""
        Set the autofeature brightness algorithm for a controller.

        Will set the controller brightness algorithm to algorithm. See #peak_afl_controller_brightness_algorithm for a list of valid values.

        :type algorithm: int, in
        :param algorithm: autofeature brightness algorithm

        :raises: Exception if function fails

        Since: 1.6
        """
        return _ids_peak_afl_python_interface.Controller_SetBrightnessAlgorithm(self, algorithm)

    def GetBrightnessAlgorithm(self) -> "peak_afl_controller_brightness_algorithm":
        r"""
        Get the current autofeature brightness algorithm for a controller.

        :rtype: int
        :return: autofeature brightness algorithm

        :raises: Exception if function fails
        """
        return _ids_peak_afl_python_interface.Controller_GetBrightnessAlgorithm(self)

    def Status(self) -> "peak_afl_controller_status":
        r"""
        Get the status for a controller.

        See #peak_afl_controller_status for a list of values.

        :rtype: int
        :return: controller status

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_Status(self)

    def GetLastAutoAverage(self) -> "int":
        r"""
        Get the last auto average for a controller.

        Used by Controllers processing a mono image.

        :rtype: int
        :return: autofeature average

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_GetLastAutoAverage(self)

    def GetLastAutoAverages(self) -> "Any":
        r"""
        Get the last auto average for a controller.

        Used by Controllers processing a color image.

        :rtype: tuple< int,int,int >
        :return: tuple<red, green, blue> in that order

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_GetLastAutoAverages(self)

    def IsAutoTargetSupported(self) -> "bool":
        r"""
        check if auto target is supported for a controller.

        True if auto target is supported, otherwise it is unsupported.

        :rtype: boolean
        :return: boolean if controller supports auto target

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_IsAutoTargetSupported(self)

    def SetAutoTarget(self, target: "int") -> "None":
        r"""
        Set the auto target for a controller.

        Set an auto target. Call #peak_afl_AutoController_AutoTarget_GetRange to get the valid range.
        End value which will be targeted by the controller.

        :type target: int, in
        :param target:     auto target value

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_SetAutoTarget(self, target)

    def GetAutoTarget(self) -> "int":
        r"""
        Get the currently set auto target for a controller.

        :rtype: int
        :return: auto target value

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_GetAutoTarget(self)

    def GetAutoTargetRange(self) -> "IntRange":
        r"""
        Get the auto target range for a controller.

        Call this function to get the range of valid values which can be set by a call to
        #SetAutoTarget.

        :rtype: Range< int >
        :return: Range with valid values

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_GetAutoTargetRange(self)

    def IsAutoToleranceSupported(self) -> "bool":
        r"""
        check if auto tolerance is supported for a controller.

        True if auto tolerance is supported, otherwise it is unsupported.

        :rtype: boolean
        :return: boolean if controller supports auto tolerance

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_IsAutoToleranceSupported(self)

    def SetAutoTolerance(self, tolerance: "int") -> "None":
        r"""
        Set the auto tolerance for a controller.

        Sets the +/- tolerance for the auto target value.

        :type tolerance: int, in
        :param tolerance:  auto target value

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_SetAutoTolerance(self, tolerance)

    def GetAutoTolerance(self) -> "int":
        r"""
        Get the current auto tolerance for a controller.

        :rtype: int
        :return: auto tolerance value

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_GetAutoTolerance(self)

    def GetAutoToleranceRange(self) -> "IntRange":
        r"""
        Get the auto tolerance range for a controller.

        Call this function to get the range of valid values which can be set by a call to
        #SetAutoTolerance.

        :rtype: Range< int >
        :return: Range with valid values

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_GetAutoToleranceRange(self)

    def IsAutoPercentileSupported(self) -> "bool":
        r"""
        check if auto percentile is supported for a controller.

        True if auto percentile is supported, otherwise it is unsupported.

        :rtype: boolean
        :return: boolean if controller supports auto percentile

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_IsAutoPercentileSupported(self)

    def SetAutoPercentile(self, percentile: "float") -> "None":
        r"""
        Set the auto percentile for a controller.

        This is the used percentile value for a controller.
        To get the valid range, call #peak_afl_AutoController_AutoPercentile_GetRange.

        :type percentile: float, in
        :param percentile: auto percentile value

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_SetAutoPercentile(self, percentile)

    def GetAutoPercentile(self) -> "float":
        r"""
        Get the auto percentile for a controller.

        :rtype: float
        :return: auto percentile value

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_GetAutoPercentile(self)

    def GetAutoPercentileRange(self) -> "DoubleRange":
        r"""
        Get the auto percentile range for a controller.

        Call this function to get the range of valid values which can be set by a call to
        #SetAutoPercentile.

        :rtype: Range< double >
        :return: Range with valid values

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_GetAutoPercentileRange(self)

    def Type(self) -> "peak_afl_controllerType":
        r"""
        Get the controller type.

        See #peak_afl_controllerType for a list of values.

        :rtype: int
        :return: auto controller type

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_Type(self)

    def IsAlgorithmSupported(self) -> "bool":
        r"""
        check if setting an algorithm is supported for a controller.

        True if algorithm is supported, otherwise it is unsupported.

        Call #GetAlgorithmList to get a list of supported algorithms.

        :rtype: boolean
        :return: boolean if controller supports setting an algorithm

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_IsAlgorithmSupported(self)

    def SetAlgorithm(self, algorithm: "peak_afl_controller_algorithm") -> "None":
        r"""
        Set the used algorithm for a controller.

        To get a list of supported algorithms see #peak_afl_AutoController_Algorithm_GetList.

        :type algorithm: int, in
        :param algorithm: auto controller algorithm

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_SetAlgorithm(self, algorithm)

    def GetAlgorithm(self) -> "peak_afl_controller_algorithm":
        r"""
        Get the used algorithm for a controller.

        :rtype: int
        :return: auto controller algorithm

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_GetAlgorithm(self)

    def GetAlgorithmList(self) -> "Sequence[peak_afl_controller_algorithm]":
        r"""
        Get the list of supported algorithms for a controller.

        To set a value, see #SetAlgorithm.

        :rtype: Sequence[peak_afl_controller_algorithm]
        :return: vector of supported algorithms

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_GetAlgorithmList(self)

    def IsSharpnessAlgorithmSupported(self) -> "bool":
        r"""
        check setting a sharpness algorithm is supported by a controller.

        True if sharpness algorithm is supported, otherwise it is unsupported.

        Call #GetSharpnessAlgorithmList to get a list of supported sharpness algorithms.

        :rtype: boolean
        :return: boolean if controller supports setting a sharpness algorithm

        :raises: Exception if function fails
        """
        return _ids_peak_afl_python_interface.Controller_IsSharpnessAlgorithmSupported(self)

    def SetSharpnessAlgorithm(self, algorithm: "peak_afl_controller_sharpness_algorithm") -> "None":
        r"""
        Set the used sharpness algorithm for a controller.

        To get a list of supported algorithms see #peak_afl_AutoController_SharpnessAlgorithm_GetList.

        :type algorithm: int, in
        :param algorithm:  auto controller sharpness algorithm

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_SetSharpnessAlgorithm(self, algorithm)

    def GetSharpnessAlgorithm(self) -> "peak_afl_controller_sharpness_algorithm":
        r"""
        Get the used sharpness algorithm for a controller.

        :rtype: int
        :return: auto controller sharpness algorithm

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_GetSharpnessAlgorithm(self)

    def GetSharpnessAlgorithmList(self) -> "Sequence[peak_afl_controller_sharpness_algorithm]":
        r"""
        Get the list of supported sharpness algorithms for a controller.

        To set a value, see #SetSharpnessAlgorithm.

        :rtype: Sequence[peak_afl_controller_sharpness_algorithm]
        :return: vector of supported algorithms

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_GetSharpnessAlgorithmList(self)

    def RegisterProcessingCallback(self, callback: "ProcessingCallback") -> "None":
        r"""
        Set the data callback for a controller.

        :type callback: ProcessingCallback
        :param callback: the processing callback

        Since: 1.7
        """
        return _ids_peak_afl_python_interface.Controller_RegisterProcessingCallback(self, callback)

    def UnRegisterProcessingCallback(self) -> "None":
        r"""
        Reset the data callback for a controller.

        Removes the previously registered callback.

        Since: 1.7
        """
        return _ids_peak_afl_python_interface.Controller_UnRegisterProcessingCallback(self)

    def IsWeightedROISupported(self) -> "bool":
        r"""
        Check if weighted region of interest is supported for a controller.

        True if weighted region of interest is supported, otherwise it is unsupported.

        :rtype: boolean
        :return: boolean if controller supports weighted roi

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_IsWeightedROISupported(self)

    def SetWeightedROIs(self, list: "WeightedRectangleList") -> "None":
        r"""
        Set the autofeature weighted region of interest for a controller.

        Already set weighted regions of interest will be overwritten

        :type list: Sequence[peak_afl_weighted_rectangle]
        :param list: vector of weighted region of interest

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_SetWeightedROIs(self, list)

    def SetWeightedROI(self, rect: "peak_afl_weighted_rectangle") -> "None":
        r"""
        Set single autofeature weighted region of interest for a controller.

        Already set weighted regions of interest will be overwritten

        :type rect: :py:class:`peak_afl_weighted_rectangle`, in
        :param rect: weighted region of interest

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_SetWeightedROI(self, rect)

    def GetWeightedROIMinSize(self) -> "peak_afl_size":
        r"""
        Get the autofeature minimum size of weighted region of interest for a controller.

        :rtype: :py:class:`peak_afl_size`
        :return: the minimum size

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_GetWeightedROIMinSize(self)

    def GetWeightedROIs(self) -> "Sequence[peak_afl_weighted_rectangle]":
        r"""
        Get the autofeature weighted region of interest for a controller.

        :rtype: Sequence[peak_afl_weighted_rectangle]
        :return: vector with set #peak_afl_weighted_rectangle

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_GetWeightedROIs(self)

    def IsLimitSupported(self) -> "bool":
        r"""
        Check if limit is supported for a controller.

        True if limit is supported, otherwise it is unsupported.

        :rtype: boolean
        :return: boolean if controller supports limit

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_IsLimitSupported(self)

    def SetLimit(self, limit: "peak_afl_controller_limit") -> "None":
        r"""
        Set the autofeature limit for a controller.

        Sets the minimum and maximum limit for the algorithm set by #peak_afl_AutoController_Algorithm_Set

        :type limit: :py:class:`peak_afl_controller_limit`, in
        :param limit:      the limit to set

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_SetLimit(self, limit)

    def GetLimit(self) -> "peak_afl_controller_limit":
        r"""
        Get the autofeature limit for a controller.

        :rtype: :py:class:`peak_afl_controller_limit`
        :return: the limit set

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_GetLimit(self)

    def GetDefaultLimit(self) -> "peak_afl_controller_limit":
        r"""
        Get the autofeature default limit.

        :rtype: :py:class:`peak_afl_controller_limit`
        :return: the default limit set

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_GetDefaultLimit(self)

    def IsHysteresisSupported(self) -> "bool":
        r"""
        Check if hysteresis is supported for a controller.

        True if hysteresis is supported, otherwise it is unsupported.

        :rtype: boolean
        :return: boolean if controller supports hysteresis

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_IsHysteresisSupported(self)

    def SetHysteresis(self, hysteresis: "int") -> "None":
        r"""
        Set the autofeature hysteresis for a controller.

        Set the hysteresis for the algorithm set by #SetAlgorithm

        :type hysteresis: int, in
        :param hysteresis: the hysteresis to set

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_SetHysteresis(self, hysteresis)

    def GetHysteresis(self) -> "int":
        r"""
        Get the autofeature hysteresis for a controller.

        :rtype: int
        :return: the hysteresis set

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_GetHysteresis(self)

    def GetDefaultHysteresis(self) -> "int":
        r"""
        Get the autofeature hysteresis default.

        :rtype: int
        :return: the default hysteresis

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_GetDefaultHysteresis(self)

    def GetHysteresisRange(self) -> "IntRange":
        r"""
        Get autofeature hysteresis range for a controller.

        :rtype: Range< int >
        :return: the Range of the hysteresis

        :raises: Exception if function fails

        Since: 1.1
        """
        return _ids_peak_afl_python_interface.Controller_GetHysteresisRange(self)

    def IsBrightnessComponentModeSupported(self) -> "bool":
        r"""
        Check if auto mode is supported for a brightness controller component.

        true if auto mode is supported, otherwise it is unsupported.

        :rtype: boolean
        :return: boolean if controller supports auto mode

        :raises: Exception if function fails

        Since: 1.2
        """
        return _ids_peak_afl_python_interface.Controller_IsBrightnessComponentModeSupported(self)

    def IsBrightnessComponentUnitSupported(self, component: "peak_afl_controller_brightness_component") -> "bool":
        r"""
        Check if a specific unit is supported for a brightness controller component.

        true if auto unit is supported, otherwise it is unsupported.

        :type component: int, in
        :param component:  autofeature brightness unit
        :rtype: boolean
        :return: boolean if controller supports auto unit

        :raises: Exception if function fails

        Since: 1.6
        """
        return _ids_peak_afl_python_interface.Controller_IsBrightnessComponentUnitSupported(self, component)

    def BrightnessComponentSetMode(self, component: "peak_afl_controller_brightness_component", mode: "peak_afl_controller_automode") -> "None":
        r"""
        Set the autofeature mode for a brightness controller component.

        Will set the controller mode to mode. See #peak_afl_controller_automode for a list of valid values.

        :type component: int, in
        :param component:  autofeature brightness component
        :type mode: int, in
        :param mode:       autofeature mode

        :raises: Exception if function fails

        Since: 1.2
        """
        return _ids_peak_afl_python_interface.Controller_BrightnessComponentSetMode(self, component, mode)

    def BrightnessComponentGetMode(self, component: "peak_afl_controller_brightness_component") -> "peak_afl_controller_automode":
        r"""
        Get the current autofeature mode for a brightness controller component.

        :type component: int, in
        :param component: autofeature brightness component
        :rtype: int
        :return: autofeature mode

        :raises: Exception if function fails

        Since: 1.2
        """
        return _ids_peak_afl_python_interface.Controller_BrightnessComponentGetMode(self, component)

    def BrightnessComponentStatus(self, component: "peak_afl_controller_brightness_component") -> "peak_afl_controller_status":
        r"""
        Get the status for a brightness controller component.

        See #peak_afl_controller_status for a list of values.

        :type component: int, in
        :param component: autofeature brightness component
        :rtype: int
        :return: controller status

        :raises: Exception if function fails

        Since: 1.2
        """
        return _ids_peak_afl_python_interface.Controller_BrightnessComponentStatus(self, component)

    def IsGainLimitSupported(self) -> "bool":
        r"""
        Check if auto gain limit is supported for a controller.

        :rtype: boolean
        :return: true if auto gain limit is supported, otherwise returns false.

        :raises: Exception if function fails

        Since: 1.3
        """
        return _ids_peak_afl_python_interface.Controller_IsGainLimitSupported(self)

    def SetGainLimit(self, limit: "peak_afl_double_limit") -> "None":
        r"""
        Set the gain limit for a controller

        The valid values are dependend on the used gain node and can be between minimum and maximum.
        Default is the complete range.
        The used priority list is: Analog -> Digital -> Any -> IPL (if supplied).

        If any value of the limit is out of range, the value is clamped to be valid. In this case no exception is thrown.
        It is recommended to check the current values by calling #GetGainLimit after this call.

        :type limit: :py:class:`peak_afl_double_limit`, in
        :param limit:      limits the controller to adjust the gain to the supplied range between min and max of ``limit``.

        :raises: Exception if function fails

        Since: 1.3
        """
        return _ids_peak_afl_python_interface.Controller_SetGainLimit(self, limit)

    def GetGainLimit(self) -> "peak_afl_double_limit":
        r"""
        Get autofeature gain limit for a controller

        :rtype: :py:class:`peak_afl_double_limit`
        :return: the current gain limit

        :raises: Exception if function fails

        Since: 1.3
        """
        return _ids_peak_afl_python_interface.Controller_GetGainLimit(self)

    def GetGainLimitRange(self) -> "peak_afl_double_limit":
        r"""
        Get autofeature gain limit range for a controller

        :rtype: :py:class:`peak_afl_double_limit`
        :return: the possible range for gain limit

        :raises: Exception if function fails

        Since: 1.3
        """
        return _ids_peak_afl_python_interface.Controller_GetGainLimitRange(self)

    def SetGainAnalogLimit(self, limit: "peak_afl_double_limit") -> "None":
        r"""
        Set the analog gain limit for a controller

        The valid values are dependend on the used gain node and can be between minimum and maximum.
        Default is the complete range.

        If any value of the limit is out of range, the value is clamped to be valid. In this case no exception is thrown.
        It is recommended to check the current values by calling #SetGainAnalogLimit after this call.

        :type limit: :py:class:`peak_afl_double_limit`, in
        :param limit:      limits the controller to adjust the analog gain to the supplied range between min and max of ``limit``.

        :raises: Exception if function fails

        Since: 1.6
        """
        return _ids_peak_afl_python_interface.Controller_SetGainAnalogLimit(self, limit)

    def GetGainAnalogLimit(self) -> "peak_afl_double_limit":
        r"""
        Get autofeature analog gain limit for a controller

        :rtype: :py:class:`peak_afl_double_limit`
        :return: the current analog gain limit

        :raises: Exception if function fails

        Since: 1.6
        """
        return _ids_peak_afl_python_interface.Controller_GetGainAnalogLimit(self)

    def GetGainAnalogLimitRange(self) -> "peak_afl_double_limit":
        r"""
        Get autofeature analog gain limit range for a controller

        :rtype: :py:class:`peak_afl_double_limit`
        :return: the possible range for analog gain limit

        :raises: Exception if function fails

        Since: 1.6
        """
        return _ids_peak_afl_python_interface.Controller_GetGainAnalogLimitRange(self)

    def SetGainDigitalLimit(self, limit: "peak_afl_double_limit") -> "None":
        r"""
        Set the digital gain limit for a controller

        The valid values are dependend on the used gain node and can be between minimum and maximum.
        Default is the complete range.

        If any value of the limit is out of range, the value is clamped to be valid. In this case no exception is thrown.
        It is recommended to check the current values by calling #GetGainDigitalLimit after this call.

        :type limit: :py:class:`peak_afl_double_limit`, in
        :param limit:      limits the controller to adjust the digital gain to the supplied range between min and max of ``limit``.

        :raises: Exception if function fails

        Since: 1.6
        """
        return _ids_peak_afl_python_interface.Controller_SetGainDigitalLimit(self, limit)

    def GetGainDigitalLimit(self) -> "peak_afl_double_limit":
        r"""
        Get autofeature digital gain limit for a controller

        :rtype: :py:class:`peak_afl_double_limit`
        :return: the current digital gain limit

        :raises: Exception if function fails

        Since: 1.6
        """
        return _ids_peak_afl_python_interface.Controller_GetGainDigitalLimit(self)

    def GetGainDigitalLimitRange(self) -> "peak_afl_double_limit":
        r"""
        Get autofeature digital gain limit range for a controller

        :rtype: :py:class:`peak_afl_double_limit`
        :return: the possible range for digital gain limit

        :raises: Exception if function fails

        Since: 1.6
        """
        return _ids_peak_afl_python_interface.Controller_GetGainDigitalLimitRange(self)

    def SetGainCombinedLimit(self, limit: "peak_afl_double_limit") -> "None":
        r"""
        Set the combined gain limit for a controller

        The valid values are dependend on the used gain node and can be between minimum and maximum.
        Default is the complete range.

        If any value of the limit is out of range, the value is clamped to be valid. In this case no exception is thrown.
        It is recommended to check the current values by calling #GetGainCombinedLimit after this call.

        :type limit: :py:class:`peak_afl_double_limit`, in
        :param limit:      limits the controller to adjust the combined gain to the supplied range between min and max of ``limit``.

        :raises: Exception if function fails

        Since: 1.6
        """
        return _ids_peak_afl_python_interface.Controller_SetGainCombinedLimit(self, limit)

    def GetGainCombinedLimit(self) -> "peak_afl_double_limit":
        r"""
        Get autofeature combined gain limit for a controller

        :rtype: :py:class:`peak_afl_double_limit`
        :return: the current combined gain limit

        :raises: Exception if function fails

        Since: 1.6
        """
        return _ids_peak_afl_python_interface.Controller_GetGainCombinedLimit(self)

    def GetGainCombinedLimitRange(self) -> "peak_afl_double_limit":
        r"""
        Get autofeature combined gain limit range for a controller

        :rtype: :py:class:`peak_afl_double_limit`
        :return: the possible range for combined gain limit

        :raises: Exception if function fails

        Since: 1.6
        """
        return _ids_peak_afl_python_interface.Controller_GetGainCombinedLimitRange(self)

    def SetGainHostLimit(self, limit: "peak_afl_double_limit") -> "None":
        r"""
        Set the host gain limit for a controller

        The valid values are dependend on the used gain node and can be between minimum and maximum.
        Default is the complete range.

        If any value of the limit is out of range, the value is clamped to be valid. In this case no exception is thrown.
        It is recommended to check the current values by calling #GetGainHostLimit after this call.

        :type limit: :py:class:`peak_afl_double_limit`, in
        :param limit:      limits the controller to adjust the host gain to the supplied range between min and max of ``limit``.

        :raises: Exception if function fails

        Since: 1.6
        """
        return _ids_peak_afl_python_interface.Controller_SetGainHostLimit(self, limit)

    def GetGainHostLimit(self) -> "peak_afl_double_limit":
        r"""
        Get autofeature host gain limit for a controller

        :rtype: :py:class:`peak_afl_double_limit`
        :return: the current host gain limit

        :raises: Exception if function fails

        Since: 1.6
        """
        return _ids_peak_afl_python_interface.Controller_GetGainHostLimit(self)

    def GetGainHostLimitRange(self) -> "peak_afl_double_limit":
        r"""
        Get autofeature host gain limit range for a controller

        :rtype: :py:class:`peak_afl_double_limit`
        :return: the possible range for host gain limit

        :raises: Exception if function fails

        Since: 1.6
        """
        return _ids_peak_afl_python_interface.Controller_GetGainHostLimitRange(self)

    def SetExposureLimit(self, limit: "peak_afl_double_limit") -> "None":
        r"""
        Set the exposure limit for a controller

        :type limit: :py:class:`peak_afl_double_limit`, in
        :param limit:      limits the controller to adjust the exposure to the supplied range between min and max of ``limit``.

        :raises: Exception if function fails

        Since: 1.4
        """
        return _ids_peak_afl_python_interface.Controller_SetExposureLimit(self, limit)

    def GetExposureLimit(self) -> "peak_afl_double_limit":
        r"""
        Get autofeature exposure limit for a controller

        :rtype: :py:class:`peak_afl_double_limit`
        :return: the current exposure limit

        :raises: Exception if function fails

        Since: 1.4
        """
        return _ids_peak_afl_python_interface.Controller_GetExposureLimit(self)

# Register Controller in _ids_peak_afl_python_interface:
_ids_peak_afl_python_interface.Controller_swigregister(Controller)
PEAK_AFL_STATUS_SUCCESS = _ids_peak_afl_python_interface.PEAK_AFL_STATUS_SUCCESS
r"""Success"""
PEAK_AFL_STATUS_ERROR = _ids_peak_afl_python_interface.PEAK_AFL_STATUS_ERROR
r"""Error"""
PEAK_AFL_STATUS_NOT_INITIALIZED = _ids_peak_afl_python_interface.PEAK_AFL_STATUS_NOT_INITIALIZED
r"""Library not initialized"""
PEAK_AFL_STATUS_INVALID_PARAMETER = _ids_peak_afl_python_interface.PEAK_AFL_STATUS_INVALID_PARAMETER
r"""Invalid Parameter"""
PEAK_AFL_STATUS_ACCESS_DENIED = _ids_peak_afl_python_interface.PEAK_AFL_STATUS_ACCESS_DENIED
r"""Access Denied"""
PEAK_AFL_STATUS_BUSY = _ids_peak_afl_python_interface.PEAK_AFL_STATUS_BUSY
r"""Busy"""
PEAK_AFL_STATUS_BUFFER_TOO_SMALL = _ids_peak_afl_python_interface.PEAK_AFL_STATUS_BUFFER_TOO_SMALL
r"""Buffer too small"""
PEAK_AFL_STATUS_INVALID_IMAGE_FORMAT = _ids_peak_afl_python_interface.PEAK_AFL_STATUS_INVALID_IMAGE_FORMAT
r"""Invalid image format"""
PEAK_AFL_STATUS_NOT_SUPPORTED = _ids_peak_afl_python_interface.PEAK_AFL_STATUS_NOT_SUPPORTED
r"""Not supported"""
PEAK_AFL_STATUS_VALUE_ADJUSTED = _ids_peak_afl_python_interface.PEAK_AFL_STATUS_VALUE_ADJUSTED
PEAK_AFL_CONTROLLER_TYPE_INVALID = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_TYPE_INVALID
r"""Invalid controller"""
PEAK_AFL_CONTROLLER_TYPE_BRIGHTNESS = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_TYPE_BRIGHTNESS
r"""Exposure controller"""
PEAK_AFL_CONTROLLER_TYPE_WHITE_BALANCE = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_TYPE_WHITE_BALANCE
r"""White balance controller"""
PEAK_AFL_CONTROLLER_TYPE_AUTOFOCUS = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_TYPE_AUTOFOCUS
r"""Autofocus Controller"""
PEAK_AFL_CONTROLLER_AUTOMODE_OFF = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_AUTOMODE_OFF
r"""Automode off"""
PEAK_AFL_CONTROLLER_AUTOMODE_CONTINUOUS = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_AUTOMODE_CONTINUOUS
r"""Automode continuous"""
PEAK_AFL_CONTROLLER_AUTOMODE_ONCE = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_AUTOMODE_ONCE
r"""Automode once"""
PEAK_AFL_CONTROLLER_STATUS_UNDEFINED = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_STATUS_UNDEFINED
r"""Controller status undefined"""
PEAK_AFL_CONTROLLER_STATUS_OFF = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_STATUS_OFF
r"""Controller status off"""
PEAK_AFL_CONTROLLER_STATUS_IN_PROGRESS = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_STATUS_IN_PROGRESS
r"""Controller status in progress"""
PEAK_AFL_CONTROLLER_STATUS_FINISHED = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_STATUS_FINISHED
r"""Controller status finished"""
PEAK_AFL_CONTROLLER_STATUS_BUSY = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_STATUS_BUSY
r"""Controller status busy"""
PEAK_AFL_CONTROLLER_STATUS_CANCELED = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_STATUS_CANCELED
r"""Controller status canceled"""
PEAK_AFL_CONTROLLER_STATUS_ERROR = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_STATUS_ERROR
r"""Controller status error"""
PEAK_AFL_CONTROLLER_STATUS_SKIPPED = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_STATUS_SKIPPED
r"""Controller status skipped"""
PEAK_AFL_CONTROLLER_ALGORITHM_AUTO = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_ALGORITHM_AUTO
r"""Controller algorithm auto"""
PEAK_AFL_CONTROLLER_ALGORITHM_GOLDEN_RATIO_SEARCH = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_ALGORITHM_GOLDEN_RATIO_SEARCH
r"""Controller algorithm golden ratio search"""
PEAK_AFL_CONTROLLER_ALGORITHM_HILL_CLIMBING_SEARCH = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_ALGORITHM_HILL_CLIMBING_SEARCH
r"""Controller algorithm hill climbing search"""
PEAK_AFL_CONTROLLER_ALGORITHM_GLOBAL_SEARCH = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_ALGORITHM_GLOBAL_SEARCH
r"""Controller algorithm global search"""
PEAK_AFL_CONTROLLER_ALGORITHM_FULL_SCAN = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_ALGORITHM_FULL_SCAN
r"""Controller algorithm full scan"""
PEAK_AFL_CONTROLLER_BRIGHTNESS_ALGORITHM_MEDIAN = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_BRIGHTNESS_ALGORITHM_MEDIAN
r"""median brightness algorithm"""
PEAK_AFL_CONTROLLER_BRIGHTNESS_ALGORITHM_MEAN = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_BRIGHTNESS_ALGORITHM_MEAN
r"""mean brightness algorithm"""
PEAK_AFL_CONTROLLER_SHARPNESS_ALGORITHM_AUTO = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_SHARPNESS_ALGORITHM_AUTO
r"""Controller sharpness algorithm auto"""
PEAK_AFL_CONTROLLER_SHARPNESS_ALGORITHM_TENENGRAD = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_SHARPNESS_ALGORITHM_TENENGRAD
r"""Controller sharpness algorithm tenengrad"""
PEAK_AFL_CONTROLLER_SHARPNESS_ALGORITHM_SOBEL = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_SHARPNESS_ALGORITHM_SOBEL
r"""Controller sharpness algorithm sobel"""
PEAK_AFL_CONTROLLER_SHARPNESS_ALGORITHM_MEAN_SCORE = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_SHARPNESS_ALGORITHM_MEAN_SCORE
r"""Controller sharpness algorithm mean score"""
PEAK_AFL_CONTROLLER_SHARPNESS_ALGORITHM_HISTOGRAM_VARIANCE = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_SHARPNESS_ALGORITHM_HISTOGRAM_VARIANCE
r"""Controller sharpness algorithm histogram variance"""
PEAK_AFL_CONTROLLER_BRIGHTNESS_COMPONENT_INVALID = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_BRIGHTNESS_COMPONENT_INVALID
r"""invalid component"""
PEAK_AFL_CONTROLLER_BRIGHTNESS_COMPONENT_EXPOSURE = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_BRIGHTNESS_COMPONENT_EXPOSURE
r"""exposure"""
PEAK_AFL_CONTROLLER_BRIGHTNESS_COMPONENT_GAIN = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_BRIGHTNESS_COMPONENT_GAIN
r"""gain"""
PEAK_AFL_CONTROLLER_BRIGHTNESS_COMPONENT_ANALOG_GAIN = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_BRIGHTNESS_COMPONENT_ANALOG_GAIN
r"""analog gain"""
PEAK_AFL_CONTROLLER_BRIGHTNESS_COMPONENT_DIGITAL_GAIN = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_BRIGHTNESS_COMPONENT_DIGITAL_GAIN
r"""digital gain"""
PEAK_AFL_CONTROLLER_BRIGHTNESS_COMPONENT_COMBINED_GAIN = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_BRIGHTNESS_COMPONENT_COMBINED_GAIN
r"""combined gain"""
PEAK_AFL_CONTROLLER_BRIGHTNESS_COMPONENT_HOST_GAIN = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_BRIGHTNESS_COMPONENT_HOST_GAIN
r"""host gain"""
PEAK_AFL_CONTROLLER_ROI_WEIGHT_WEAK = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_ROI_WEIGHT_WEAK
r"""Controller roi weight weak"""
PEAK_AFL_CONTROLLER_ROI_WEIGHT_MEDIUM = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_ROI_WEIGHT_MEDIUM
r"""Controller roi weight middle"""
PEAK_AFL_CONTROLLER_ROI_WEIGHT_STRONG = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_ROI_WEIGHT_STRONG
r"""Controller roi weight strong"""
PEAK_AFL_CONTROLLER_CALLBACK_FINISHED = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_CALLBACK_FINISHED
r"""Controller callback type finished"""
PEAK_AFL_CONTROLLER_CALLBACK_PROCESSING_DATA = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_CALLBACK_PROCESSING_DATA
r"""
     Controller callback type processing

    Deprecated: use #PEAK_AFL_CONTROLLER_CALLBACK_PROCESSING instead
    """
PEAK_AFL_CONTROLLER_CALLBACK_PROCESSING = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_CALLBACK_PROCESSING
r"""Controller callback type processing"""
class peak_afl_process_data(object):
    r"""generic process data"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    controller_status: "peak_afl_controller_status" = property(_ids_peak_afl_python_interface.peak_afl_process_data_controller_status_get, _ids_peak_afl_python_interface.peak_afl_process_data_controller_status_set)
    controller_type: "peak_afl_controllerType" = property(_ids_peak_afl_python_interface.peak_afl_process_data_controller_type_get, _ids_peak_afl_python_interface.peak_afl_process_data_controller_type_set)
    reserved: "char [32]" = property(_ids_peak_afl_python_interface.peak_afl_process_data_reserved_get, _ids_peak_afl_python_interface.peak_afl_process_data_reserved_set)

    def __init__(self):
        _ids_peak_afl_python_interface.peak_afl_process_data_swiginit(self, _ids_peak_afl_python_interface.new_peak_afl_process_data())
    __swig_destroy__ = _ids_peak_afl_python_interface.delete_peak_afl_process_data

# Register peak_afl_process_data in _ids_peak_afl_python_interface:
_ids_peak_afl_python_interface.peak_afl_process_data_swigregister(peak_afl_process_data)
class peak_afl_process_data_brightness(object):
    r"""brightness process data"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    controller_status: "peak_afl_controller_status" = property(_ids_peak_afl_python_interface.peak_afl_process_data_brightness_controller_status_get, _ids_peak_afl_python_interface.peak_afl_process_data_brightness_controller_status_set)
    controller_type: "peak_afl_controllerType" = property(_ids_peak_afl_python_interface.peak_afl_process_data_brightness_controller_type_get, _ids_peak_afl_python_interface.peak_afl_process_data_brightness_controller_type_set)
    controller_component: "peak_afl_controller_brightness_component" = property(_ids_peak_afl_python_interface.peak_afl_process_data_brightness_controller_component_get, _ids_peak_afl_python_interface.peak_afl_process_data_brightness_controller_component_set)
    mean: "int" = property(_ids_peak_afl_python_interface.peak_afl_process_data_brightness_mean_get, _ids_peak_afl_python_interface.peak_afl_process_data_brightness_mean_set)
    reserved: "char [64]" = property(_ids_peak_afl_python_interface.peak_afl_process_data_brightness_reserved_get, _ids_peak_afl_python_interface.peak_afl_process_data_brightness_reserved_set)

    def __init__(self):
        _ids_peak_afl_python_interface.peak_afl_process_data_brightness_swiginit(self, _ids_peak_afl_python_interface.new_peak_afl_process_data_brightness())
    __swig_destroy__ = _ids_peak_afl_python_interface.delete_peak_afl_process_data_brightness

# Register peak_afl_process_data_brightness in _ids_peak_afl_python_interface:
_ids_peak_afl_python_interface.peak_afl_process_data_brightness_swigregister(peak_afl_process_data_brightness)
class peak_afl_process_data_whitebalance(object):
    r"""whitebalance process data"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    controller_status: "peak_afl_controller_status" = property(_ids_peak_afl_python_interface.peak_afl_process_data_whitebalance_controller_status_get, _ids_peak_afl_python_interface.peak_afl_process_data_whitebalance_controller_status_set)
    controller_type: "peak_afl_controllerType" = property(_ids_peak_afl_python_interface.peak_afl_process_data_whitebalance_controller_type_get, _ids_peak_afl_python_interface.peak_afl_process_data_whitebalance_controller_type_set)
    mean_r: "int" = property(_ids_peak_afl_python_interface.peak_afl_process_data_whitebalance_mean_r_get, _ids_peak_afl_python_interface.peak_afl_process_data_whitebalance_mean_r_set)
    mean_g: "int" = property(_ids_peak_afl_python_interface.peak_afl_process_data_whitebalance_mean_g_get, _ids_peak_afl_python_interface.peak_afl_process_data_whitebalance_mean_g_set)
    mean_b: "int" = property(_ids_peak_afl_python_interface.peak_afl_process_data_whitebalance_mean_b_get, _ids_peak_afl_python_interface.peak_afl_process_data_whitebalance_mean_b_set)
    reserved: "char [64]" = property(_ids_peak_afl_python_interface.peak_afl_process_data_whitebalance_reserved_get, _ids_peak_afl_python_interface.peak_afl_process_data_whitebalance_reserved_set)

    def __init__(self):
        _ids_peak_afl_python_interface.peak_afl_process_data_whitebalance_swiginit(self, _ids_peak_afl_python_interface.new_peak_afl_process_data_whitebalance())
    __swig_destroy__ = _ids_peak_afl_python_interface.delete_peak_afl_process_data_whitebalance

# Register peak_afl_process_data_whitebalance in _ids_peak_afl_python_interface:
_ids_peak_afl_python_interface.peak_afl_process_data_whitebalance_swigregister(peak_afl_process_data_whitebalance)
class peak_afl_process_data_focus(object):
    r"""focus process data"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    controller_status: "peak_afl_controller_status" = property(_ids_peak_afl_python_interface.peak_afl_process_data_focus_controller_status_get, _ids_peak_afl_python_interface.peak_afl_process_data_focus_controller_status_set)
    controller_type: "peak_afl_controllerType" = property(_ids_peak_afl_python_interface.peak_afl_process_data_focus_controller_type_get, _ids_peak_afl_python_interface.peak_afl_process_data_focus_controller_type_set)
    focus_value: "int" = property(_ids_peak_afl_python_interface.peak_afl_process_data_focus_focus_value_get, _ids_peak_afl_python_interface.peak_afl_process_data_focus_focus_value_set)
    sharpness_value: "int" = property(_ids_peak_afl_python_interface.peak_afl_process_data_focus_sharpness_value_get, _ids_peak_afl_python_interface.peak_afl_process_data_focus_sharpness_value_set)
    reserved: "char [64]" = property(_ids_peak_afl_python_interface.peak_afl_process_data_focus_reserved_get, _ids_peak_afl_python_interface.peak_afl_process_data_focus_reserved_set)

    def __init__(self):
        _ids_peak_afl_python_interface.peak_afl_process_data_focus_swiginit(self, _ids_peak_afl_python_interface.new_peak_afl_process_data_focus())
    __swig_destroy__ = _ids_peak_afl_python_interface.delete_peak_afl_process_data_focus

# Register peak_afl_process_data_focus in _ids_peak_afl_python_interface:
_ids_peak_afl_python_interface.peak_afl_process_data_focus_swigregister(peak_afl_process_data_focus)
PEAK_AFL_CONTROLLER_ROI_PRESET_CENTER = _ids_peak_afl_python_interface.PEAK_AFL_CONTROLLER_ROI_PRESET_CENTER
r"""controller roi preset center"""
class peak_afl_size(object):
    r"""
    peak_afl Size (2D)

    Defines a size in a 2-dimensional coordinate space.

    This type is used in several library functions and types.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    width: "int" = property(_ids_peak_afl_python_interface.peak_afl_size_width_get, _ids_peak_afl_python_interface.peak_afl_size_width_set, doc=r"""Width""")
    height: "int" = property(_ids_peak_afl_python_interface.peak_afl_size_height_get, _ids_peak_afl_python_interface.peak_afl_size_height_set, doc=r"""Height""")

    def __init__(self):
        _ids_peak_afl_python_interface.peak_afl_size_swiginit(self, _ids_peak_afl_python_interface.new_peak_afl_size())
    __swig_destroy__ = _ids_peak_afl_python_interface.delete_peak_afl_size

# Register peak_afl_size in _ids_peak_afl_python_interface:
_ids_peak_afl_python_interface.peak_afl_size_swigregister(peak_afl_size)
class peak_afl_position(object):
    r"""
    peak_afl Position (2D)

    Defines a position in a 2-dimensional coordinate space.

    This type is used in several library functions and types.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    x: "int" = property(_ids_peak_afl_python_interface.peak_afl_position_x_get, _ids_peak_afl_python_interface.peak_afl_position_x_set, doc=r"""X-Position""")
    y: "int" = property(_ids_peak_afl_python_interface.peak_afl_position_y_get, _ids_peak_afl_python_interface.peak_afl_position_y_set, doc=r"""Y-Position""")

    def __init__(self):
        _ids_peak_afl_python_interface.peak_afl_position_swiginit(self, _ids_peak_afl_python_interface.new_peak_afl_position())
    __swig_destroy__ = _ids_peak_afl_python_interface.delete_peak_afl_position

# Register peak_afl_position in _ids_peak_afl_python_interface:
_ids_peak_afl_python_interface.peak_afl_position_swigregister(peak_afl_position)
class peak_afl_rectangle(object):
    r"""
    peak_afl Rectangle (2D)

    Defines a position in a 2-dimensional coordinate space.

    This type is used in several library functions and types.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    x: "int" = property(_ids_peak_afl_python_interface.peak_afl_rectangle_x_get, _ids_peak_afl_python_interface.peak_afl_rectangle_x_set, doc=r"""X-Position""")
    y: "int" = property(_ids_peak_afl_python_interface.peak_afl_rectangle_y_get, _ids_peak_afl_python_interface.peak_afl_rectangle_y_set, doc=r"""Y-Position""")
    width: "int" = property(_ids_peak_afl_python_interface.peak_afl_rectangle_width_get, _ids_peak_afl_python_interface.peak_afl_rectangle_width_set, doc=r"""Width""")
    height: "int" = property(_ids_peak_afl_python_interface.peak_afl_rectangle_height_get, _ids_peak_afl_python_interface.peak_afl_rectangle_height_set, doc=r"""Height""")

    def __init__(self):
        _ids_peak_afl_python_interface.peak_afl_rectangle_swiginit(self, _ids_peak_afl_python_interface.new_peak_afl_rectangle())
    __swig_destroy__ = _ids_peak_afl_python_interface.delete_peak_afl_rectangle

# Register peak_afl_rectangle in _ids_peak_afl_python_interface:
_ids_peak_afl_python_interface.peak_afl_rectangle_swigregister(peak_afl_rectangle)
class peak_afl_weighted_rectangle(object):
    r"""
    peak_afl Focus Rectangle

    Defines a focus roi.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    roi: "peak_afl_rectangle" = property(_ids_peak_afl_python_interface.peak_afl_weighted_rectangle_roi_get, _ids_peak_afl_python_interface.peak_afl_weighted_rectangle_roi_set, doc=r"""Roi""")
    weight: "peak_afl_roi_weight" = property(_ids_peak_afl_python_interface.peak_afl_weighted_rectangle_weight_get, _ids_peak_afl_python_interface.peak_afl_weighted_rectangle_weight_set, doc=r"""Weight""")

    def __init__(self):
        _ids_peak_afl_python_interface.peak_afl_weighted_rectangle_swiginit(self, _ids_peak_afl_python_interface.new_peak_afl_weighted_rectangle())
    __swig_destroy__ = _ids_peak_afl_python_interface.delete_peak_afl_weighted_rectangle

# Register peak_afl_weighted_rectangle in _ids_peak_afl_python_interface:
_ids_peak_afl_python_interface.peak_afl_weighted_rectangle_swigregister(peak_afl_weighted_rectangle)
class peak_afl_controller_limit(object):
    r"""
    peak_afl Focus Limit

    Defines a focus limit.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    min: "int" = property(_ids_peak_afl_python_interface.peak_afl_controller_limit_min_get, _ids_peak_afl_python_interface.peak_afl_controller_limit_min_set, doc=r"""Minimum""")
    max: "int" = property(_ids_peak_afl_python_interface.peak_afl_controller_limit_max_get, _ids_peak_afl_python_interface.peak_afl_controller_limit_max_set, doc=r"""Maximum""")

    def __init__(self):
        _ids_peak_afl_python_interface.peak_afl_controller_limit_swiginit(self, _ids_peak_afl_python_interface.new_peak_afl_controller_limit())
    __swig_destroy__ = _ids_peak_afl_python_interface.delete_peak_afl_controller_limit

# Register peak_afl_controller_limit in _ids_peak_afl_python_interface:
_ids_peak_afl_python_interface.peak_afl_controller_limit_swigregister(peak_afl_controller_limit)
class peak_afl_double_limit(object):
    r"""
    peak_afl Double Limit

    Defines a limit with double values
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    min: "float" = property(_ids_peak_afl_python_interface.peak_afl_double_limit_min_get, _ids_peak_afl_python_interface.peak_afl_double_limit_min_set, doc=r"""Minimum""")
    max: "float" = property(_ids_peak_afl_python_interface.peak_afl_double_limit_max_get, _ids_peak_afl_python_interface.peak_afl_double_limit_max_set, doc=r"""Maximum""")

    def __init__(self):
        _ids_peak_afl_python_interface.peak_afl_double_limit_swiginit(self, _ids_peak_afl_python_interface.new_peak_afl_double_limit())
    __swig_destroy__ = _ids_peak_afl_python_interface.delete_peak_afl_double_limit

# Register peak_afl_double_limit in _ids_peak_afl_python_interface:
_ids_peak_afl_python_interface.peak_afl_double_limit_swigregister(peak_afl_double_limit)
class IntRange(object):
    r"""
    /ingroup cpp
    Simple range type
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    min: "int" = property(_ids_peak_afl_python_interface.IntRange_min_get, _ids_peak_afl_python_interface.IntRange_min_set)
    max: "int" = property(_ids_peak_afl_python_interface.IntRange_max_get, _ids_peak_afl_python_interface.IntRange_max_set)
    inc: "int" = property(_ids_peak_afl_python_interface.IntRange_inc_get, _ids_peak_afl_python_interface.IntRange_inc_set)

    def __init__(self):
        _ids_peak_afl_python_interface.IntRange_swiginit(self, _ids_peak_afl_python_interface.new_IntRange())
    __swig_destroy__ = _ids_peak_afl_python_interface.delete_IntRange

# Register IntRange in _ids_peak_afl_python_interface:
_ids_peak_afl_python_interface.IntRange_swigregister(IntRange)
class DoubleRange(object):
    r"""
    /ingroup cpp
    Simple range type
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    min: "float" = property(_ids_peak_afl_python_interface.DoubleRange_min_get, _ids_peak_afl_python_interface.DoubleRange_min_set)
    max: "float" = property(_ids_peak_afl_python_interface.DoubleRange_max_get, _ids_peak_afl_python_interface.DoubleRange_max_set)
    inc: "float" = property(_ids_peak_afl_python_interface.DoubleRange_inc_get, _ids_peak_afl_python_interface.DoubleRange_inc_set)

    def __init__(self):
        _ids_peak_afl_python_interface.DoubleRange_swiginit(self, _ids_peak_afl_python_interface.new_DoubleRange())
    __swig_destroy__ = _ids_peak_afl_python_interface.delete_DoubleRange

# Register DoubleRange in _ids_peak_afl_python_interface:
_ids_peak_afl_python_interface.DoubleRange_swigregister(DoubleRange)
class UCharRange(object):
    r"""
    /ingroup cpp
    Simple range type
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    min: "int" = property(_ids_peak_afl_python_interface.UCharRange_min_get, _ids_peak_afl_python_interface.UCharRange_min_set)
    max: "int" = property(_ids_peak_afl_python_interface.UCharRange_max_get, _ids_peak_afl_python_interface.UCharRange_max_set)
    inc: "int" = property(_ids_peak_afl_python_interface.UCharRange_inc_get, _ids_peak_afl_python_interface.UCharRange_inc_set)

    def __init__(self):
        _ids_peak_afl_python_interface.UCharRange_swiginit(self, _ids_peak_afl_python_interface.new_UCharRange())
    __swig_destroy__ = _ids_peak_afl_python_interface.delete_UCharRange

# Register UCharRange in _ids_peak_afl_python_interface:
_ids_peak_afl_python_interface.UCharRange_swigregister(UCharRange)
class ControllerAlgorithmList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    def __iter__(self):
        return self.iterator()

    def __init__(self, *args):
        _ids_peak_afl_python_interface.ControllerAlgorithmList_swiginit(self, _ids_peak_afl_python_interface.new_ControllerAlgorithmList(*args))
    __swig_destroy__ = _ids_peak_afl_python_interface.delete_ControllerAlgorithmList

# Register ControllerAlgorithmList in _ids_peak_afl_python_interface:
_ids_peak_afl_python_interface.ControllerAlgorithmList_swigregister(ControllerAlgorithmList)
class ControllerBrightnessAlgorithmList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    def __iter__(self):
        return self.iterator()

    def __init__(self, *args):
        _ids_peak_afl_python_interface.ControllerBrightnessAlgorithmList_swiginit(self, _ids_peak_afl_python_interface.new_ControllerBrightnessAlgorithmList(*args))
    __swig_destroy__ = _ids_peak_afl_python_interface.delete_ControllerBrightnessAlgorithmList

# Register ControllerBrightnessAlgorithmList in _ids_peak_afl_python_interface:
_ids_peak_afl_python_interface.ControllerBrightnessAlgorithmList_swigregister(ControllerBrightnessAlgorithmList)
class ControllerSharpnessAlgorithmList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    def __iter__(self):
        return self.iterator()

    def __init__(self, *args):
        _ids_peak_afl_python_interface.ControllerSharpnessAlgorithmList_swiginit(self, _ids_peak_afl_python_interface.new_ControllerSharpnessAlgorithmList(*args))
    __swig_destroy__ = _ids_peak_afl_python_interface.delete_ControllerSharpnessAlgorithmList

# Register ControllerSharpnessAlgorithmList in _ids_peak_afl_python_interface:
_ids_peak_afl_python_interface.ControllerSharpnessAlgorithmList_swigregister(ControllerSharpnessAlgorithmList)
class ControllerList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "SwigPyIterator":
        return _ids_peak_afl_python_interface.ControllerList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _ids_peak_afl_python_interface.ControllerList___nonzero__(self)

    def __bool__(self) -> "bool":
        return _ids_peak_afl_python_interface.ControllerList___bool__(self)

    def __len__(self) -> "Any":
        return _ids_peak_afl_python_interface.ControllerList___len__(self)

    def __getslice__(self, i: "Any", j: "Any") -> "Sequence[Controller]":
        return _ids_peak_afl_python_interface.ControllerList___getslice__(self, i, j)

    def __setslice__(self, *args) -> "None":
        return _ids_peak_afl_python_interface.ControllerList___setslice__(self, *args)

    def __delslice__(self, i: "Any", j: "Any") -> "None":
        return _ids_peak_afl_python_interface.ControllerList___delslice__(self, i, j)

    def __delitem__(self, *args) -> "None":
        return _ids_peak_afl_python_interface.ControllerList___delitem__(self, *args)

    def __getitem__(self, *args) -> "Any":
        return _ids_peak_afl_python_interface.ControllerList___getitem__(self, *args)

    def __setitem__(self, *args) -> "None":
        return _ids_peak_afl_python_interface.ControllerList___setitem__(self, *args)

    def pop(self) -> "Any":
        return _ids_peak_afl_python_interface.ControllerList_pop(self)

    def append(self, x: "Any") -> "None":
        return _ids_peak_afl_python_interface.ControllerList_append(self, x)

    def empty(self) -> "bool":
        return _ids_peak_afl_python_interface.ControllerList_empty(self)

    def size(self) -> "Any":
        return _ids_peak_afl_python_interface.ControllerList_size(self)

    def swap(self, v: "ControllerList") -> "None":
        return _ids_peak_afl_python_interface.ControllerList_swap(self, v)

    def begin(self) -> "Any":
        return _ids_peak_afl_python_interface.ControllerList_begin(self)

    def end(self) -> "Any":
        return _ids_peak_afl_python_interface.ControllerList_end(self)

    def rbegin(self) -> "Any":
        return _ids_peak_afl_python_interface.ControllerList_rbegin(self)

    def rend(self) -> "Any":
        return _ids_peak_afl_python_interface.ControllerList_rend(self)

    def clear(self) -> "None":
        return _ids_peak_afl_python_interface.ControllerList_clear(self)

    def get_allocator(self) -> "Any":
        return _ids_peak_afl_python_interface.ControllerList_get_allocator(self)

    def pop_back(self) -> "None":
        return _ids_peak_afl_python_interface.ControllerList_pop_back(self)

    def erase(self, *args) -> "Any":
        return _ids_peak_afl_python_interface.ControllerList_erase(self, *args)

    def __init__(self, *args):
        _ids_peak_afl_python_interface.ControllerList_swiginit(self, _ids_peak_afl_python_interface.new_ControllerList(*args))

    def push_back(self, x: "Any") -> "None":
        return _ids_peak_afl_python_interface.ControllerList_push_back(self, x)

    def front(self) -> "Any":
        return _ids_peak_afl_python_interface.ControllerList_front(self)

    def back(self) -> "Any":
        return _ids_peak_afl_python_interface.ControllerList_back(self)

    def assign(self, n: "Any", x: "Any") -> "None":
        return _ids_peak_afl_python_interface.ControllerList_assign(self, n, x)

    def resize(self, *args) -> "None":
        return _ids_peak_afl_python_interface.ControllerList_resize(self, *args)

    def insert(self, *args) -> "None":
        return _ids_peak_afl_python_interface.ControllerList_insert(self, *args)

    def reserve(self, n: "Any") -> "None":
        return _ids_peak_afl_python_interface.ControllerList_reserve(self, n)

    def capacity(self) -> "Any":
        return _ids_peak_afl_python_interface.ControllerList_capacity(self)
    __swig_destroy__ = _ids_peak_afl_python_interface.delete_ControllerList

# Register ControllerList in _ids_peak_afl_python_interface:
_ids_peak_afl_python_interface.ControllerList_swigregister(ControllerList)
class WeightedRectangleList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    def __iter__(self):
        return self.iterator()

    def __init__(self, *args):
        _ids_peak_afl_python_interface.WeightedRectangleList_swiginit(self, _ids_peak_afl_python_interface.new_WeightedRectangleList(*args))
    __swig_destroy__ = _ids_peak_afl_python_interface.delete_WeightedRectangleList

# Register WeightedRectangleList in _ids_peak_afl_python_interface:
_ids_peak_afl_python_interface.WeightedRectangleList_swigregister(WeightedRectangleList)

