"""
task domain model object
"""

from datetime import datetime, timedelta
from typing import Annotated, Any, Literal

from pydantic import AwareDatetime, BaseModel, ConfigDict, Field

from taskdependencygraph.models.ids import TaskId
from taskdependencygraph.models.person import Person


class TaskNode(BaseModel):
    """
    This is a task domain model for task instances, that we use as nodes in the task dependency graph.
    It is _not_ the task MODEL, which helps to create task instance in the DB.
    It is also _not_ the task DTO, which passes through the API.
    """

    model_config = ConfigDict(frozen=True)
    # the Task has to be frozen/hashable to be used as a node in a networkx graph
    # How to use model_config: https://docs.pydantic.dev/latest/api/config/#pydantic.config.ConfigDict.frozen
    # NetworkX restrictions regarding "nodes have to be hashable":
    # https://networkx.org/documentation/stable/reference/classes/generated/networkx.DiGraph.add_node.html

    # Q: Why the 2 IDs (internal and external)?
    # A: The internal ID is to identify tasks technically (e.g. in the database).
    # It may also be used by the frontend to update 1 specific task instance.
    # In this case, the external ID is not unique, because tasks with the same ID may exist in different graphs.
    # The external ID is for human users to identify tasks (within a graph).
    # In Excel, both internal and external ID were the same, because 2 runs resulted in 2 Excel sheets.
    # There was no conflict or ambiguity because those tasks which shared the same ID were spread over multiple
    # Excel files.
    # We don't have multiple databases or tables for tasks in different graphs.
    # Hence, we need the 2 IDs.

    id: TaskId
    """
    The ID is technically unique.
    No two task instances ever share the same id.
    Other than the external_id the ID is usually autogenerated and less handy for the user, because it's a GUID and not
    a small readable string.
    """
    external_id: Annotated[str, Field(min_length=1)]
    """
    The external_id is unique within a single TaskDependencyGraph.
    It is, what the user 'sees' as an ID (Example: 'MS1000').
    But it's not unique enough to identify a task in the database.
    The value is initially provided by the frontend/user.
    """
    name: Annotated[str, Field(min_length=1)]
    """
    The name is not necessarily unique. 
    Example: 'Beginn der Migrationsvorarbeiten'
    The value is provided by the frontend.
    """
    phase: Annotated[str, Field(min_length=1)] | None = None
    """ 
    The task dependency graph is divided into phases by milestones.
    Example: '1000'
    The value may be provided by the frontend.
    """
    tags: list[Annotated[str, Field(min_length=1)]] | None = None
    """
    Tasks can have none, one or more tags. Tags are a possibility to group tasks.
    Example: ['IS-U', 'Rechnungen'].
    """
    planned_duration: Annotated[timedelta, Field(min=timedelta(minutes=0))]
    """ 
    The planned_duration_minutes expresses how long the task execution is planned to last (in minutes).
    Example: timedelta(minutes=600) (for 10h)
    The value is provided by the frontend.
    """
    is_milestone: bool = False
    """
    Expresses if a task is a milestone.
    Milestones are Pseudo-Tasks with duration = 0 and execution_status = COMPLETED.
    It begins and ends a phase.
    """

    earliest_starttime: AwareDatetime | None = None
    """
    A possibility to set a fixed earliest start time for a task.
    The task may only start at this datetime or later, even if predecessors finish earlier.
    """

    planned_duration_of_predecessor_tasks: Annotated[timedelta, Field(min=timedelta(minutes=0))] | None = None
    """
    The planned_duration_of_predecessor_tasks is the sum of the duration of the predecessor tasks. 
    The planned_duration_of_predecessor_tasks expresses, how long it takes from the beginning of the first task 
    to the task in question.
    It is needed to calculate the the planned_start_time of the task in question, as the planned_start_time of the task
    in question is calculated from the planned_start_time of the first task and the 
    planned_duration_of_predecessor_tasks. 
    Example: Example: timedelta(minutes=660) (for 11h)
    This value is computed with the help of NetworkX.
    """
    planned_starting_time: datetime | None = None
    """
    The planned_start_time is the time when the execution of the task in question is planned to start.
    It is calculated from the planned_start_time of the first task and the planned_duration_of_predecessor_tasks. 
    """

    assignee: Person | None = None
    """
    The assignee of the task.
    """

    def to_dot(self, attributes: dict[Literal["label", "color"], Any]) -> str:
        """
        returns a dot representation of this task/node
        For details on the dot language see https://graphviz.org/doc/info/lang.html
        """
        # we always pass along the id of the node with the dot string to that the svg element has the ID "svg-<id>"
        # https://graphviz.org/docs/attrs/id/
        result = f'"{self.id}"[id="svg-{self.id}";'
        for key, value in attributes.items():
            result += f'{key}="{value}";'
        result += "];\n"
        return result


__all__ = ["TaskNode"]
