{"version":3,"file":"vendors-node_modules_codemirror-lang-macaulay2_dist_index_js.715f3e2d34136524b2d0.js","mappings":";;;;;;;;;;;;;AAAO;AACP;AACA,kBAAkB,kCAAkC;AACpD;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,KAAK;AACL;AACA,eAAe;AACf;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,oBAAoB;AAC9C;AACA,kCAAkC,2CAA2C;AAC7E;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB,sBAAsB,kBAAkB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACrIsD;AACiB;;AAEvE,sBAAsB,qFAAU;AAChC;AACA,UAAU,mDAAmD;AAC7D,UAAU,iFAAiF;AAC3F,UAAU,wCAAwC;AAClD,UAAU,6CAA6C;AACvD,UAAU,gEAAgE;AAC1E;AACA;AACA,UAAU;AACV,8BAA8B;AAC9B,UAAU;AACV,0BAA0B;AAC1B,UAAU;AACV,0BAA0B;AAC1B,UAAU,8EAA8E;AACxF,UAAU,WAAW,sBAAsB;AAC3C,UAAU,WAAW,KAAK,kBAAkB;AAC5C,UAAU,0CAA0C;AACpD,UAAU,2CAA2C;AACrD,UAAU,iCAAiC;AAC3C;AACA,CAAC;AACD,wBAAwB,gEAAc;;AAEjB","sources":["webpack://jupyterlab-macaulay2/./node_modules/@codemirror/legacy-modes/mode/simple-mode.js","webpack://jupyterlab-macaulay2/./node_modules/codemirror-lang-macaulay2/dist/index.js"],"sourcesContent":["export function simpleMode(states) {\n  ensureState(states, \"start\");\n  var states_ = {}, meta = states.languageData || {}, hasIndentation = false;\n  for (var state in states) if (state != meta && states.hasOwnProperty(state)) {\n    var list = states_[state] = [], orig = states[state];\n    for (var i = 0; i < orig.length; i++) {\n      var data = orig[i];\n      list.push(new Rule(data, states));\n      if (data.indent || data.dedent) hasIndentation = true;\n    }\n  }\n  return {\n    name: meta.name,\n    startState: function() {\n      return {state: \"start\", pending: null, indent: hasIndentation ? [] : null};\n    },\n    copyState: function(state) {\n      var s = {state: state.state, pending: state.pending, indent: state.indent && state.indent.slice(0)};\n      if (state.stack)\n        s.stack = state.stack.slice(0);\n      return s;\n    },\n    token: tokenFunction(states_),\n    indent: indentFunction(states_, meta),\n    languageData: meta\n  }\n};\n\nfunction ensureState(states, name) {\n  if (!states.hasOwnProperty(name))\n    throw new Error(\"Undefined state \" + name + \" in simple mode\");\n}\n\nfunction toRegex(val, caret) {\n  if (!val) return /(?:)/;\n  var flags = \"\";\n  if (val instanceof RegExp) {\n    if (val.ignoreCase) flags = \"i\";\n    val = val.source;\n  } else {\n    val = String(val);\n  }\n  return new RegExp((caret === false ? \"\" : \"^\") + \"(?:\" + val + \")\", flags);\n}\n\nfunction asToken(val) {\n  if (!val) return null;\n  if (val.apply) return val\n  if (typeof val == \"string\") return val.replace(/\\./g, \" \");\n  var result = [];\n  for (var i = 0; i < val.length; i++)\n    result.push(val[i] && val[i].replace(/\\./g, \" \"));\n  return result;\n}\n\nfunction Rule(data, states) {\n  if (data.next || data.push) ensureState(states, data.next || data.push);\n  this.regex = toRegex(data.regex);\n  this.token = asToken(data.token);\n  this.data = data;\n}\n\nfunction tokenFunction(states) {\n  return function(stream, state) {\n    if (state.pending) {\n      var pend = state.pending.shift();\n      if (state.pending.length == 0) state.pending = null;\n      stream.pos += pend.text.length;\n      return pend.token;\n    }\n\n    var curState = states[state.state];\n    for (var i = 0; i < curState.length; i++) {\n      var rule = curState[i];\n      var matches = (!rule.data.sol || stream.sol()) && stream.match(rule.regex);\n      if (matches) {\n        if (rule.data.next) {\n          state.state = rule.data.next;\n        } else if (rule.data.push) {\n          (state.stack || (state.stack = [])).push(state.state);\n          state.state = rule.data.push;\n        } else if (rule.data.pop && state.stack && state.stack.length) {\n          state.state = state.stack.pop();\n        }\n\n        if (rule.data.indent)\n          state.indent.push(stream.indentation() + stream.indentUnit);\n        if (rule.data.dedent)\n          state.indent.pop();\n        var token = rule.token\n        if (token && token.apply) token = token(matches)\n        if (matches.length > 2 && rule.token && typeof rule.token != \"string\") {\n          state.pending = [];\n          for (var j = 2; j < matches.length; j++)\n            if (matches[j])\n              state.pending.push({text: matches[j], token: rule.token[j - 1]});\n          stream.backUp(matches[0].length - (matches[1] ? matches[1].length : 0));\n          return token[0];\n        } else if (token && token.join) {\n          return token[0];\n        } else {\n          return token;\n        }\n      }\n    }\n    stream.next();\n    return null;\n  };\n}\n\nfunction indentFunction(states, meta) {\n  return function(state, textAfter) {\n    if (state.indent == null || meta.dontIndentStates && meta.dontIndentStates.indexOf(state.state) > -1)\n      return null\n\n    var pos = state.indent.length - 1, rules = states[state.state];\n    scan: for (;;) {\n      for (var i = 0; i < rules.length; i++) {\n        var rule = rules[i];\n        if (rule.data.dedent && rule.data.dedentIfLineStart !== false) {\n          var m = rule.regex.exec(textAfter);\n          if (m && m[0]) {\n            pos--;\n            if (rule.next || rule.push) rules = states[rule.next || rule.push];\n            textAfter = textAfter.slice(m[0].length);\n            continue scan;\n          }\n        }\n      }\n      break;\n    }\n    return pos < 0 ? 0 : state.indent[pos];\n  };\n}\n","import { StreamLanguage } from '@codemirror/language';\nimport { simpleMode } from '@codemirror/legacy-modes/mode/simple-mode';\n\nconst Macaulay2Mode = simpleMode({\n    start: [\n        { regex: /\"(?:[^\\\\]|\\\\.)*?(?:\"|$)/, token: \"string\" },\n        { regex: /(then|do|list|in|break|continue|not|and|or|return)\\b/, token: \"keyword\" },\n        { regex: /(from|to)\\b/, token: \"builtin\" },\n        { regex: /(true|false|null)\\b/, token: \"atom\" },\n        { regex: /(for|while|if|else)\\b/, token: \"keyword\", indent: true },\n        /* testing */\n        /* symbols from M2-symbols.el here */\n        { regex: /(and|break|catch|continue|do|elapsedTime|elapsedTiming|else|for|from|global|if|in|list|local|new|not|of|or|return|shield|SPACE|step|symbol|then|threadVariable|throw|time|timing|to|try|when|while|xor)\\b/,\n            token: \"keyword\" },\n        { regex: /(Adjacent|AffineVariety|Analyzer|ANCHOR|AngleBarList|Array|AssociativeExpression|Bag|BasicList|BettiTally|BinaryOperation|BLOCKQUOTE|BODY|BOLD|Boolean|BR|CacheFunction|CacheTable|CC|CDATA|ChainComplex|ChainComplexMap|CODE|CoherentSheaf|Command|COMMENT|CompiledFunction|CompiledFunctionBody|CompiledFunctionClosure|ComplexField|Constant|Database|DD|Descent|Describe|Dictionary|DIV|Divide|DL|DocumentTag|DT|Eliminate|EM|EngineRing|Equation|ExampleItem|Expression|File|FilePosition|FractionField|Function|FunctionApplication|FunctionBody|FunctionClosure|GaloisField|GeneralOrderedMonoid|GlobalDictionary|GradedModule|GradedModuleMap|GroebnerBasis|GroebnerBasisOptions|HashTable|HEAD|HEADER1|HEADER2|HEADER3|HEADER4|HEADER5|HEADER6|HeaderType|Holder|HR|HREF|HTML|Hybrid|Hypertext|HypertextContainer|HypertextParagraph|Ideal|IMG|ImmutableType|IndeterminateNumber|IndexedVariable|IndexedVariableTable|InexactField|InexactFieldFamily|InexactNumber|InfiniteNumber|IntermediateMarkUpType|ITALIC|Keyword|LABEL|LATER|LI|LINK|List|LITERAL|LocalDictionary|LowerBound|Manipulator|MapExpression|MarkUpType|Matrix|MatrixExpression|MENU|META|MethodFunction|MethodFunctionBinary|MethodFunctionSingle|MethodFunctionWithOptions|Minus|Module|Monoid|MonoidElement|MonomialIdeal|MultigradedBettiTally|MutableHashTable|MutableList|MutableMatrix|Net|NetFile|NonAssociativeProduct|Nothing|Number|NumberedVerticalList|OL|OneExpression|Option|OptionTable|OrderedMonoid|Package|PARA|Parenthesize|Parser|Partition|PolynomialRing|Power|PRE|Product|ProductOrder|Program|ProgramRun|ProjectiveHilbertPolynomial|ProjectiveVariety|Pseudocode|QQ|QuotientRing|RealField|Resolution|Ring|RingElement|RingFamily|RingMap|RowExpression|RR|RRi|SCRIPT|ScriptedFunctor|SelfInitializingType|Sequence|Set|SheafExpression|SheafOfRings|SMALL|SPAN|SparseMonomialVectorExpression|SparseVectorExpression|String|STRONG|STYLE|SUB|Subscript|SUBSECTION|Sum|SumOfTwists|SUP|Superscript|Symbol|SymbolBody|TABLE|Table|Tally|Task|TD|TestInput|TEX|TH|Thing|Time|TITLE|TO|TO2|TOH|TR|TT|Type|UL|URL|Variety|Vector|VectorExpression|VerticalList|VirtualTally|VisibleList|WrapperType|ZeroExpression|ZZ)\\b/,\n            token: \"tag\" },\n        { regex: /(about|abs|accumulate|acos|acosh|acot|acoth|addCancelTask|addDependencyTask|addEndFunction|addHook|addStartFunction|addStartTask|adjoint|agm|alarm|all|ambient|analyticSpread|ancestor|ancestors|andP|ann|annihilator|antipode|any|append|applicationDirectory|apply|applyKeys|applyPairs|applyTable|applyValues|apropos|arXiv|ascii|asin|asinh|ass|assert|associatedGradedRing|associatedPrimes|atan|atan2|atanh|atEndOfFile|autoload|baseFilename|baseName|baseRing|basis|beginDocumentation|benchmark|BesselJ|BesselY|Beta|betti|between|binomial|borel|cacheValue|cancelTask|capture|ceiling|centerString|chainComplex|char|characters|charAnalyzer|check|checkDegrees|chi|class|clean|clearEcho|code|codim|coefficient|coefficientRing|coefficients|cohomology|coimage|coker|cokernel|collectGarbage|columnAdd|columnate|columnMult|columnPermute|columnRankProfile|columnSwap|combine|commandInterpreter|commonest|commonRing|comodule|complement|complete|components|compose|compositions|compress|concatenate|conductor|cone|conjugate|connectionCount|constParser|content|contract|conwayPolynomial|copy|copyDirectory|copyFile|cos|cosh|cot|cotangentSheaf|coth|cover|coverMap|cpuTime|createTask|csc|csch|currentColumnNumber|currentDirectory|currentPosition|currentRowNumber|currentTime|deadParser|debug|debugError|decompose|deepSplice|default|degree|degreeLength|degrees|degreesMonoid|degreesRing|delete|demark|denominator|depth|describe|det|determinant|diagonalMatrix|diameter|dictionary|diff|difference|Digamma|dim|directSum|disassemble|discriminant|dismiss|distinguished|divideByVariable|doc|document|drop|dual|eagonNorthcott|echoOff|echoOn|eigenvalues|eigenvectors|eint|elements|eliminate|End|endPackage|entries|erase|erf|erfc|error|euler|eulers|even|EXAMPLE|examples|exec|exp|expectedReesIdeal|expm1|exponents|export|exportFrom|exportMutable|expression|extend|exteriorPower|factor|Fano|fileExecutable|fileExists|fileLength|fileMode|fileReadable|fileTime|fileWritable|fillMatrix|findFiles|findHeft|findProgram|findSynonyms|first|firstkey|fittingIdeal|flagLookup|flatten|flattenRing|flip|floor|fold|forceGB|fork|format|formation|frac|fraction|frames|fromDividedPowers|fromDual|functionBody|futureParser|Gamma|gb|gbRemove|gbSnapshot|gcd|gcdCoefficients|gcdLLL|GCstats|genera|generateAssertions|generator|generators|genericMatrix|genericSkewMatrix|genericSymmetricMatrix|gens|genus|get|getc|getChangeMatrix|getenv|getGlobalSymbol|getNetFile|getNonUnit|getPrimeWithRootOfUnity|getSymbol|getWWW|GF|globalAssign|globalAssignFunction|globalAssignment|globalReleaseFunction|gradedModule|gradedModuleMap|gramm|graphIdeal|graphRing|Grassmannian|groebnerBasis|groupID|hash|hashTable|heft|height|hermite|hilbertFunction|hilbertPolynomial|hilbertSeries|hold|Hom|homogenize|homology|homomorphism|hooks|horizontalJoin|html|httpHeaders|hypertext|icFracP|icFractions|icMap|icPIdeal|ideal|idealizer|identity|image|imaginaryPart|importFrom|independentSets|index|indices|inducedMap|inducesWellDefinedMap|info|input|insert|installAssignmentMethod|installedPackages|installHilbertFunction|installMethod|installMinprimes|installPackage|instance|instances|integralClosure|integrate|intersect|intersectInP|intersection|interval|inverse|inverseErf|inversePermutation|inverseRegularizedBeta|inverseRegularizedGamma|inverseSystem|irreducibleCharacteristicSeries|irreducibleDecomposition|isAffineRing|isANumber|isBorel|isc|isCanceled|isCommutative|isConstant|isDirectory|isDirectSum|isEmpty|isField|isFinite|isFinitePrimeField|isFreeModule|isGlobalSymbol|isHomogeneous|isIdeal|isInfinite|isInjective|isInputFile|isIsomorphic|isIsomorphism|isLinearType|isListener|isLLL|isMember|isModule|isMonomialIdeal|isNormal|isOpen|isOutputFile|isPolynomialRing|isPrimary|isPrime|isPrimitive|isPseudoprime|isQuotientModule|isQuotientOf|isQuotientRing|isReady|isReal|isReduction|isRegularFile|isRing|isSkewCommutative|isSorted|isSquareFree|isStandardGradedPolynomialRing|isSubmodule|isSubquotient|isSubset|isSupportedInZeroLocus|isSurjective|isTable|isUnit|isWellDefined|isWeylAlgebra|jacobian|jacobianDual|join|ker|kernel|kernelLLL|kernelOfLocalization|keys|kill|koszul|last|lcm|leadCoefficient|leadComponent|leadMonomial|leadTerm|left|length|letterParser|lift|liftable|limitFiles|limitProcesses|lines|linkFile|listForm|listSymbols|LLL|lngamma|load|loadPackage|localDictionaries|localize|locate|log|log1p|lookup|lookupCount|LUdecomposition|M2CODE|makeDirectory|makeDocumentTag|makePackageIndex|makeS2|map|markedGB|match|mathML|matrix|max|maxPosition|member|memoize|memoizeClear|memoizeValues|merge|mergePairs|method|methodOptions|methods|midpoint|min|mingens|mingle|minimalBetti|minimalPresentation|minimalPrimes|minimalReduction|minimizeFilename|minors|minPosition|minPres|minprimes|minus|mkdir|mod|module|modulo|monoid|monomialCurveIdeal|monomialIdeal|monomials|monomialSubideal|moveFile|multidegree|multidoc|multigraded|multiplicity|mutable|mutableIdentity|mutableMatrix|nanosleep|needs|needsPackage|net|netList|newClass|newCoordinateSystem|newNetFile|newPackage|newRing|nextkey|nextPrime|NNParser|nonspaceAnalyzer|norm|normalCone|notImplemented|nullhomotopy|nullParser|nullSpace|number|numcols|numColumns|numerator|numeric|numericInterval|numgens|numRows|numrows|odd|oeis|ofClass|on|openDatabase|openDatabaseOut|openFiles|openIn|openInOut|openListener|openOut|openOutAppend|optionalSignParser|options|optP|orP|override|pack|package|packageTemplate|pad|pager|pairs|parent|part|partition|partitions|parts|pdim|peek|permanents|permutations|pfaffians|pivots|plus|poincare|poincareN|polarize|poly|position|positions|power|powermod|precision|preimage|prepend|presentation|pretty|primaryComponent|primaryDecomposition|print|printerr|printString|processID|product|profile|Proj|projectiveHilbertPolynomial|promote|protect|prune|pseudocode|pseudoRemainder|pushForward|QQParser|QRDecomposition|quotient|quotientRemainder|radical|radicalContainment|random|randomKRationalPoint|randomMutableMatrix|rank|read|readDirectory|readlink|readPackage|realPart|realpath|recursionDepth|reducedRowEchelonForm|reduceHilbert|reductionNumber|reesAlgebra|reesAlgebraIdeal|reesIdeal|regex|regexQuote|registerFinalizer|regSeqInIdeal|regularity|regularizedBeta|regularizedGamma|relations|relativizeFilename|remainder|remove|removeDirectory|removeFile|removeLowestDimension|reorganize|replace|res|reshape|resolution|resultant|reverse|right|ring|ringFromFractions|roots|rotate|round|rowAdd|rowMult|rowPermute|rowRankProfile|rowSwap|rsort|run|runHooks|runLengthEncode|runProgram|same|saturate|scan|scanKeys|scanLines|scanPairs|scanValues|schedule|schreyerOrder|Schubert|searchPath|sec|sech|seeParsing|select|selectInSubring|selectVariables|separate|separateRegexp|sequence|serialNumber|set|setEcho|setGroupID|setIOExclusive|setIOSynchronized|setIOUnSynchronized|setRandomSeed|setup|setupEmacs|sheaf|sheafHom|show|showHtml|showTex|simpleDocFrob|sin|singularLocus|sinh|size|size2|sleep|smithNormalForm|solve|someTerms|sort|sortColumns|source|span|Spec|specialFiber|specialFiberIdeal|splice|splitWWW|sqrt|stack|stacksProject|standardForm|standardPairs|stashValue|status|style|sub|sublists|submatrix|submatrixByDegrees|subquotient|subsets|substitute|substring|subtable|sum|super|support|SVD|switch|sylvesterMatrix|symbolBody|symlinkDirectory|symlinkFile|symmetricAlgebra|symmetricAlgebraIdeal|symmetricKernel|symmetricPower|synonym|SYNOPSIS|syz|syzygyScheme|table|take|tally|tan|tangentCone|tangentSheaf|tanh|target|taskResult|temporaryFileName|tensor|tensorAssociativity|terminalParser|terms|TEST|testHunekeQuestion|tests|tex|texMath|times|toAbsolutePath|toCC|toDividedPowers|toDual|toExternalString|toField|toList|toLower|top|topCoefficients|topComponents|toRR|toRRi|toSequence|toString|toUpper|trace|transpose|trim|truncate|truncateOutput|tutorial|ultimate|unbag|uncurry|undocumented|uniform|uninstallAllPackages|uninstallPackage|unique|uniquePermutations|unsequence|unstack|urlEncode|use|userSymbols|utf8|utf8check|validate|value|values|variety|vars|vector|versalEmbedding|wait|wedgeProduct|weightRange|whichGm|width|wikipedia|wrap|youngest|zero|zeta|ZZParser)\\b/,\n            token: \"def\" },\n        { regex: /0x[a-f\\d]+|[-+]?(?:\\.\\d+|\\d+\\.?\\d*)(?:e[-+]?\\d+)?/i, token: \"number\" },\n        { regex: /[\\{\\[\\(]/, indent: true },\n        { regex: /[\\}\\]\\);]/, dedent: true },\n        { regex: /[a-z$][\\w$]*/, token: \"variable\" },\n        { regex: /^\\s*--%.*/, token: \"comment meta\" },\n        { regex: /--.*/, token: \"comment\" },\n    ]\n});\nconst macaulay2 = () => StreamLanguage.define(Macaulay2Mode);\n\nexport { macaulay2 };\n"],"names":[],"sourceRoot":""}