{
  "name": "code_search",
  "path": "/Users/martinsumera/projects/ai/kmp_coder/vanilla/code_search",
  "last_modified": "2024-12-04T16:57:20.285322",
  "public_interface": null,
  "description": "The `/Users/martinsumera/projects/ai/kmp_coder/vanilla/code_search` directory is dedicated to the development of a code search and analysis tool that leverages language models (LLMs) for enhanced functionality. It contains a modular set of Python files that work collaboratively to provide features such as file relevancy assessment, code description extraction, and overall code searching capabilities.\n\nKey components include:\n- **llm**: This subdirectory houses files specifically for LLM processing. `llm_file_relevancy.py` implements the `FileRelevancyLLMProcessor` class for determining file relevancy based on queries, while `llm_file_description.py` contains the `FileDescriptionLLMProcessor` class for extracting descriptions from code files. The `__init__.py` file in this subdirectory provides a `CodeSearcher` class for initializing and executing searches.\n\n- **File System Management**: The directory also includes files like `file_system_nodes.py`, which defines the structure for representing files and directories, and `code_search_tree_processor.py`, which processes the file system tree and generates descriptions using LLM processors.\n\n- **Search Functionality**: The `code_search.py` file contains the `CodeSearch` class, which performs searches within the project, utilizing various components to evaluate code files based on their relevance to search queries.\n\n- **Persistence and Tree Management**: Files such as `code_search_persistence.py` and `code_search_tree_creator.py` provide functionality for saving and loading file structures, as well as building and managing the file system tree.\n\nThe directory follows a clear modular design pattern, with each file encapsulating specific functionalities, enhancing readability and maintainability. This organization allows developers to easily navigate the codebase and extend its capabilities as needed.",
  "children": [
    {
      "name": "llm",
      "path": "/Users/martinsumera/projects/ai/kmp_coder/vanilla/code_search/llm",
      "last_modified": "2024-12-03T15:35:41.402195",
      "public_interface": null,
      "description": "The `/Users/martinsumera/projects/ai/kmp_coder/vanilla/code_search/llm` directory is designed for processing and analyzing code files using language models (LLMs). It contains several Python files that work together to provide functionalities for determining file relevancy and extracting descriptions from code.\n\n1. **llm_file_relevancy.py**: This file implements the `FileRelevancyLLMProcessor` class, which analyzes multiple files asynchronously to determine their relevancy based on a given query. It includes the `FileRelevancyResult` data model to structure the relevancy results.\n\n2. **llm_file_description.py**: This file focuses on extracting the public interface and descriptions from code files. It contains the `FileDescriptionLLMProcessor` class, which utilizes the `FileDescriptionResult` data model to hold the results of the analysis.\n\n3. **__init__.py**: This file serves as a utility for searching code within a specified directory. It provides the `CodeSearcher` class, which includes methods for initializing searches, executing them, and retrieving results. A default search path constant is also defined for ease of use.\n\nThe directory follows a modular design pattern, where each file encapsulates specific functionalities related to LLM processing. The use of clear class and method names enhances readability and maintainability, making it easier for developers to understand and extend the system.",
      "children": [
        {
          "name": "llm_file_relevancy.py",
          "path": "/Users/martinsumera/projects/ai/kmp_coder/vanilla/code_search/llm/llm_file_relevancy.py",
          "last_modified": "2024-12-04T15:01:32.218578",
          "public_interface": "\n# Keep all imports\nfrom pathlib import Path\nimport re\nfrom typing import List\nfrom pydantic import BaseModel\nfrom concurrent.futures import ThreadPoolExecutor\nimport asyncio\n\nfrom vanilla.code_search.file_system_nodes import FileNode\nfrom vanilla.execution_context import ExecutionContext\nfrom vanilla.llm import LLM_MODEL\nfrom vanilla.llm_executor import LLMExecutor\nfrom vanilla.llm_tag import LLMTag\nfrom vanilla.utils.async_execution import AsyncExecution\n\nclass FileRelevancyResult(BaseModel):\n    \"\"\"\n    Represents the result of a file relevancy check.\n\n    Attributes:\n        file_path: The path of the file being analyzed.\n        is_relevant: A boolean indicating if the file is relevant to the query.\n        relevance_score: A float score representing the relevance of the file.\n        explanation: A string providing an explanation for the relevancy decision.\n    \"\"\"\n    file_path: Path\n    is_relevant: bool\n    relevance_score: float\n    explanation: str\n\nclass FileRelevancyLLMProcessor:\n    \"\"\"\n    Processor for determining the relevancy of files based on a query using LLM.\n\n    Attributes:\n        llm_executor: An instance of LLMExecutor for generating responses.\n        async_execution: An instance of AsyncExecution for handling asynchronous tasks.\n    \"\"\"\n    \n    def __init__(self, llm_executor: LLMExecutor, async_execution: AsyncExecution):\n        \"\"\"\n        Initializes the FileRelevancyLLMProcessor with the given LLMExecutor and AsyncExecution.\n\n        Args:\n            llm_executor: An instance of LLMExecutor.\n            async_execution: An instance of AsyncExecution.\n        \"\"\"\n        self.llm_executor = llm_executor\n        self.async_execution = async_execution\n\n    def determine_relevancy(\n        self,\n        query: str,\n        file_nodes: List[FileNode],\n        context: ExecutionContext,\n    ) -> List[FileRelevancyResult]:\n        \"\"\"\n        Determines the relevancy of multiple files for a given query.\n\n        Args:\n            query: The query string to analyze against the files.\n            file_nodes: A list of FileNode instances representing the files to check.\n            context: The execution context for the LLM.\n\n        Returns:\n            A list of FileRelevancyResult containing relevancy information for each file.\n        \"\"\"\n        args_list = [(query, file_node.path, context) for file_node in file_nodes]\n        return self.async_execution.run_async_tasks_in_executor(self._determine_relevancy_for_single_file, *args_list)\n\n# Global variables/constants (if any)\n_SYSTEM_PROMPT_FILE_RELEVANCY: str = \"\"\"\nYou are a code analyzer that determines the relevancy of a file based on a given query.\n\nYour task is to analyze the file content and decide if it is relevant to the query. Provide a relevance score between 0 and 1, and an explanation for your decision.\n\n1 - The file is totally irrelevant to the query and it is exactly what the query asks for.\n1..0.8 - The file is relevant to the query, but it is not exactly what the query asks for.\n0.8..0.5 - The file may be relevant to the query.\n0.5..0.3 - The file is probably not relevant to the query.\n0.3..0 - The file is not relevant to the query.\n\nRules:\n1. Consider the context of the query and the file content.\n2. Evaluate if the file contains elements related to the query.\n3. Provide a boolean indicating relevancy (true/false).\n4. Assign a relevance score (0 to 1) based on the strength of the match.\n5. Offer a clear explanation for your decision.\n\nFormat your response as follows:\n\n<answer>\n<reasoning>Reasoning why the file is relevant or not relevant to the query.</reasoning>\n<score>0.85</score>\n<is_relevant>true</is_relevant>\n</answer>\n\nRemember:\n- Be concise and clear in your explanation.\n- Use the relevance score to reflect the degree of match.\n- Ensure the response is well-structured and follows the format.\n\"\"\"\n",
          "description": "\nThis file contains the implementation of a processor that determines the relevancy of files based on a given query using a language model (LLM). It includes a data model for the relevancy results and a method to analyze multiple files asynchronously. The public interface consists of the `FileRelevancyResult` data model and the `FileRelevancyLLMProcessor` class with its constructor and the `determine_relevancy` method.\n",
          "file_size": 4516,
          "file_hash": "64eddc1cfc06cc361ec8079229d1f4f4896bbdc1d380e47c910d278270aa92ec",
          "full_path": "/Users/martinsumera/projects/ai/kmp_coder/vanilla/code_search/llm/llm_file_relevancy.py",
          "extension": "py",
          "_type": "FileNode"
        },
        {
          "name": "llm_directory_description.py",
          "path": "/Users/martinsumera/projects/ai/kmp_coder/vanilla/code_search/llm/llm_directory_description.py",
          "last_modified": "2024-12-04T10:34:37.641666",
          "public_interface": "\n# Keep all imports\nfrom typing import List\nfrom pydantic import BaseModel\nfrom vanilla.code_search.file_system_nodes import DirectoryNode\nfrom vanilla.llm_executor import LLMExecutor\nfrom vanilla.execution_context import ExecutionContext\nfrom vanilla.llm import LLM_MODEL\nfrom vanilla.llm_tag import LLMTag\n\nclass DirectoryDescriptionResult(BaseModel):\n    \"\"\"\n    Represents the result of a directory description extraction.\n\n    Attributes:\n        description: A string containing the description of the directory.\n    \"\"\"\n    description: str\n\nclass DirectoryDescriptionLLMProcessor:\n    \"\"\"\n    Processor for extracting directory descriptions using a language model.\n\n    Attributes:\n        llm_executor: An instance of LLMExecutor used to generate descriptions.\n    \"\"\"\n    \n    def __init__(self, llm_executor: LLMExecutor) -> None:\n        \"\"\"\n        Initializes the DirectoryDescriptionLLMProcessor with an LLMExecutor.\n\n        Args:\n            llm_executor: An instance of LLMExecutor for generating descriptions.\n        \"\"\"\n        self.llm_executor = llm_executor\n\n    def extract_directory_description(self, directory_node: DirectoryNode) -> DirectoryDescriptionResult:\n        \"\"\"\n        Extract directory description including descriptions of all direct children (files and subdirectories).\n        \n        Raises:\n            ValueError: If any child description is missing.\n\n        Args:\n            directory_node: The DirectoryNode representing the directory to analyze.\n\n        Returns:\n            DirectoryDescriptionResult: The result containing the directory description.\n        \"\"\"\n        pass  # Implementation details omitted\n\n# Global variables/constants (if any)\n_SYSTEM_PROMPT: str = \"\"\"\nYou are a directory analyzer that creates comprehensive directory descriptions. You have background in software engineering and are able to understand the purpose of the code in the directory.\n\nYour task is to analyze a directory structure and create a clear description that explains:\n1. The overall purpose of the directory\n2. How the contents work together\n3. Any important patterns or conventions\n\nYour description will be used to help LLM agents understand the purpose of the directory and its contents. So make it descriptive and helpful.\n\nFormat your response as follows:\n\n<answer>\n<reasoning>\nA detailed explanation of your thought process for creating the description.\n</reasoning>\n<description>\nA clear, concise description of the directory that explains its purpose, contents, and how they work together.\nThe description should help developers understand what they can find in this directory and how it's organized.\n</description>\n</answer>\n\nRemember:\n- Focus on the directory's role in the larger system\n- Explain relationships between contained files/subdirectories\n- Highlight important patterns or conventions\n- Keep descriptions clear and concise\n\"\"\"\n",
          "description": "\nA clear, concise description of the directory that explains its purpose, contents, and how they work together.\nThe description should help developers understand what they can find in this directory and how it's organized.\n",
          "file_size": 4244,
          "file_hash": "6485edef1d803f05f6134ecba560d4acc5e12301a72160fe199ce978d1d22ba1",
          "full_path": "/Users/martinsumera/projects/ai/kmp_coder/vanilla/code_search/llm/llm_directory_description.py",
          "extension": "py",
          "_type": "FileNode"
        },
        {
          "name": "llm_file_description.py",
          "path": "/Users/martinsumera/projects/ai/kmp_coder/vanilla/code_search/llm/llm_file_description.py",
          "last_modified": "2024-12-04T14:46:09.864473",
          "public_interface": "\n# Keep all imports\nimport inspect\nfrom pydantic import BaseModel\nfrom vanilla.llm_executor import LLMExecutor\nfrom vanilla.execution_context import ExecutionContext\nfrom vanilla.llm import LLM_MODEL\nimport re\nfrom vanilla.llm_tag import LLMTag\n\nclass FileDescriptionResult(BaseModel):\n    \"\"\"\n    Represents the result of extracting a public interface and its description.\n    \n    Attributes:\n        public_interface: A string representation of the public interface.\n        description: A string description of the file.\n    \"\"\"\n    public_interface: str\n    description: str\n\nclass FileDescriptionLLMProcessor:\n    \"\"\"\n    Processor for extracting public interface information from code files using LLM.\n    \n    Attributes:\n        llm_executor: An instance of LLMExecutor used for generating responses.\n    \"\"\"\n\n    def __init__(self, llm_executor: LLMExecutor) -> None:\n        \"\"\"\n        Initializes the FileDescriptionLLMProcessor with an LLMExecutor.\n        \n        Args:\n            llm_executor: An instance of LLMExecutor to be used for LLM operations.\n        \"\"\"\n        self.llm_executor = llm_executor\n\n    def extract_public_interface_and_description(self, file_content: str, file_path: str) -> FileDescriptionResult:\n        \"\"\"\n        Extract public interface information from file content using LLM.\n        \n        Args:\n            file_content: The content of the file to analyze.\n            file_path: The path of the file being analyzed.\n            \n        Returns:\n            A FileDescriptionResult containing the public interface and description.\n        \"\"\"\n        pass  # Implementation details omitted\n",
          "description": "\nThis file contains classes and methods for extracting the public interface and description from code files using a language model. The `FileDescriptionResult` class is a data model for holding the results, while the `FileDescriptionLLMProcessor` class provides functionality to analyze code and return the public interface and description.\n",
          "file_size": 4147,
          "file_hash": "db5f6e2f537df05102152191456d43e4aead9851ace57e91aa3632aab6b227d5",
          "full_path": "/Users/martinsumera/projects/ai/kmp_coder/vanilla/code_search/llm/llm_file_description.py",
          "extension": "py",
          "_type": "FileNode"
        },
        {
          "name": "__init__.py",
          "path": "/Users/martinsumera/projects/ai/kmp_coder/vanilla/code_search/llm/__init__.py",
          "last_modified": "2024-12-03T14:55:51.072857",
          "public_interface": "\n# Keep all imports\nfrom typing import List, Optional\n\nclass CodeSearcher:\n    \"\"\"\n    A class to perform code searching operations.\n    \n    Attributes:\n        search_path (str): The path where the search will be conducted.\n    \"\"\"\n    \n    def __init__(self, search_path: str):\n        \"\"\"\n        Initializes the CodeSearcher with a specific search path.\n        \n        Args:\n            search_path: The directory path to search for code.\n        \"\"\"\n        pass  # Implementation details omitted\n\n    def search(self, query: str) -> List[str]:\n        \"\"\"\n        Searches for the given query in the specified search path.\n        \n        Args:\n            query: The search term to look for in the code files.\n            \n        Returns:\n            A list of file paths where the query was found.\n        \"\"\"\n        pass  # Implementation details omitted\n\n    def get_results(self) -> List[str]:\n        \"\"\"\n        Retrieves the results of the last search.\n        \n        Returns:\n            A list of results from the last search operation.\n        \"\"\"\n        pass  # Implementation details omitted\n\n# Global variables/constants (if any)\nDEFAULT_SEARCH_PATH: str = \"/usr/local/src\"  # Default path for searching code\n",
          "description": "\nThis file contains the implementation of a code searching utility. It provides a class `CodeSearcher` that allows users to search for specific queries within a designated directory. The public interface includes methods for initializing the searcher, performing searches, and retrieving results. Additionally, a default search path constant is defined for convenience.\n",
          "file_size": 0,
          "file_hash": "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
          "full_path": "/Users/martinsumera/projects/ai/kmp_coder/vanilla/code_search/llm/__init__.py",
          "extension": "py",
          "_type": "FileNode"
        }
      ],
      "full_path": "/Users/martinsumera/projects/ai/kmp_coder/vanilla/code_search/llm",
      "files": [
        {
          "name": "llm_file_relevancy.py",
          "path": "/Users/martinsumera/projects/ai/kmp_coder/vanilla/code_search/llm/llm_file_relevancy.py",
          "last_modified": "2024-12-04T15:01:32.218578",
          "should_be_recalculated": false,
          "public_interface": "\n# Keep all imports\nfrom pathlib import Path\nimport re\nfrom typing import List\nfrom pydantic import BaseModel\nfrom concurrent.futures import ThreadPoolExecutor\nimport asyncio\n\nfrom vanilla.code_search.file_system_nodes import FileNode\nfrom vanilla.execution_context import ExecutionContext\nfrom vanilla.llm import LLM_MODEL\nfrom vanilla.llm_executor import LLMExecutor\nfrom vanilla.llm_tag import LLMTag\nfrom vanilla.utils.async_execution import AsyncExecution\n\nclass FileRelevancyResult(BaseModel):\n    \"\"\"\n    Represents the result of a file relevancy check.\n\n    Attributes:\n        file_path: The path of the file being analyzed.\n        is_relevant: A boolean indicating if the file is relevant to the query.\n        relevance_score: A float score representing the relevance of the file.\n        explanation: A string providing an explanation for the relevancy decision.\n    \"\"\"\n    file_path: Path\n    is_relevant: bool\n    relevance_score: float\n    explanation: str\n\nclass FileRelevancyLLMProcessor:\n    \"\"\"\n    Processor for determining the relevancy of files based on a query using LLM.\n\n    Attributes:\n        llm_executor: An instance of LLMExecutor for generating responses.\n        async_execution: An instance of AsyncExecution for handling asynchronous tasks.\n    \"\"\"\n    \n    def __init__(self, llm_executor: LLMExecutor, async_execution: AsyncExecution):\n        \"\"\"\n        Initializes the FileRelevancyLLMProcessor with the given LLMExecutor and AsyncExecution.\n\n        Args:\n            llm_executor: An instance of LLMExecutor.\n            async_execution: An instance of AsyncExecution.\n        \"\"\"\n        self.llm_executor = llm_executor\n        self.async_execution = async_execution\n\n    def determine_relevancy(\n        self,\n        query: str,\n        file_nodes: List[FileNode],\n        context: ExecutionContext,\n    ) -> List[FileRelevancyResult]:\n        \"\"\"\n        Determines the relevancy of multiple files for a given query.\n\n        Args:\n            query: The query string to analyze against the files.\n            file_nodes: A list of FileNode instances representing the files to check.\n            context: The execution context for the LLM.\n\n        Returns:\n            A list of FileRelevancyResult containing relevancy information for each file.\n        \"\"\"\n        args_list = [(query, file_node.path, context) for file_node in file_nodes]\n        return self.async_execution.run_async_tasks_in_executor(self._determine_relevancy_for_single_file, *args_list)\n\n# Global variables/constants (if any)\n_SYSTEM_PROMPT_FILE_RELEVANCY: str = \"\"\"\nYou are a code analyzer that determines the relevancy of a file based on a given query.\n\nYour task is to analyze the file content and decide if it is relevant to the query. Provide a relevance score between 0 and 1, and an explanation for your decision.\n\n1 - The file is totally irrelevant to the query and it is exactly what the query asks for.\n1..0.8 - The file is relevant to the query, but it is not exactly what the query asks for.\n0.8..0.5 - The file may be relevant to the query.\n0.5..0.3 - The file is probably not relevant to the query.\n0.3..0 - The file is not relevant to the query.\n\nRules:\n1. Consider the context of the query and the file content.\n2. Evaluate if the file contains elements related to the query.\n3. Provide a boolean indicating relevancy (true/false).\n4. Assign a relevance score (0 to 1) based on the strength of the match.\n5. Offer a clear explanation for your decision.\n\nFormat your response as follows:\n\n<answer>\n<reasoning>Reasoning why the file is relevant or not relevant to the query.</reasoning>\n<score>0.85</score>\n<is_relevant>true</is_relevant>\n</answer>\n\nRemember:\n- Be concise and clear in your explanation.\n- Use the relevance score to reflect the degree of match.\n- Ensure the response is well-structured and follows the format.\n\"\"\"\n",
          "description": "\nThis file contains the implementation of a processor that determines the relevancy of files based on a given query using a language model (LLM). It includes a data model for the relevancy results and a method to analyze multiple files asynchronously. The public interface consists of the `FileRelevancyResult` data model and the `FileRelevancyLLMProcessor` class with its constructor and the `determine_relevancy` method.\n",
          "file_size": 4516,
          "file_hash": "64eddc1cfc06cc361ec8079229d1f4f4896bbdc1d380e47c910d278270aa92ec",
          "full_path": "/Users/martinsumera/projects/ai/kmp_coder/vanilla/code_search/llm/llm_file_relevancy.py",
          "extension": "py"
        },
        {
          "name": "llm_directory_description.py",
          "path": "/Users/martinsumera/projects/ai/kmp_coder/vanilla/code_search/llm/llm_directory_description.py",
          "last_modified": "2024-12-04T10:34:37.641666",
          "should_be_recalculated": false,
          "public_interface": "\n# Keep all imports\nfrom typing import List\nfrom pydantic import BaseModel\nfrom vanilla.code_search.file_system_nodes import DirectoryNode\nfrom vanilla.llm_executor import LLMExecutor\nfrom vanilla.execution_context import ExecutionContext\nfrom vanilla.llm import LLM_MODEL\nfrom vanilla.llm_tag import LLMTag\n\nclass DirectoryDescriptionResult(BaseModel):\n    \"\"\"\n    Represents the result of a directory description extraction.\n\n    Attributes:\n        description: A string containing the description of the directory.\n    \"\"\"\n    description: str\n\nclass DirectoryDescriptionLLMProcessor:\n    \"\"\"\n    Processor for extracting directory descriptions using a language model.\n\n    Attributes:\n        llm_executor: An instance of LLMExecutor used to generate descriptions.\n    \"\"\"\n    \n    def __init__(self, llm_executor: LLMExecutor) -> None:\n        \"\"\"\n        Initializes the DirectoryDescriptionLLMProcessor with an LLMExecutor.\n\n        Args:\n            llm_executor: An instance of LLMExecutor for generating descriptions.\n        \"\"\"\n        self.llm_executor = llm_executor\n\n    def extract_directory_description(self, directory_node: DirectoryNode) -> DirectoryDescriptionResult:\n        \"\"\"\n        Extract directory description including descriptions of all direct children (files and subdirectories).\n        \n        Raises:\n            ValueError: If any child description is missing.\n\n        Args:\n            directory_node: The DirectoryNode representing the directory to analyze.\n\n        Returns:\n            DirectoryDescriptionResult: The result containing the directory description.\n        \"\"\"\n        pass  # Implementation details omitted\n\n# Global variables/constants (if any)\n_SYSTEM_PROMPT: str = \"\"\"\nYou are a directory analyzer that creates comprehensive directory descriptions. You have background in software engineering and are able to understand the purpose of the code in the directory.\n\nYour task is to analyze a directory structure and create a clear description that explains:\n1. The overall purpose of the directory\n2. How the contents work together\n3. Any important patterns or conventions\n\nYour description will be used to help LLM agents understand the purpose of the directory and its contents. So make it descriptive and helpful.\n\nFormat your response as follows:\n\n<answer>\n<reasoning>\nA detailed explanation of your thought process for creating the description.\n</reasoning>\n<description>\nA clear, concise description of the directory that explains its purpose, contents, and how they work together.\nThe description should help developers understand what they can find in this directory and how it's organized.\n</description>\n</answer>\n\nRemember:\n- Focus on the directory's role in the larger system\n- Explain relationships between contained files/subdirectories\n- Highlight important patterns or conventions\n- Keep descriptions clear and concise\n\"\"\"\n",
          "description": "\nA clear, concise description of the directory that explains its purpose, contents, and how they work together.\nThe description should help developers understand what they can find in this directory and how it's organized.\n",
          "file_size": 4244,
          "file_hash": "6485edef1d803f05f6134ecba560d4acc5e12301a72160fe199ce978d1d22ba1",
          "full_path": "/Users/martinsumera/projects/ai/kmp_coder/vanilla/code_search/llm/llm_directory_description.py",
          "extension": "py"
        },
        {
          "name": "llm_file_description.py",
          "path": "/Users/martinsumera/projects/ai/kmp_coder/vanilla/code_search/llm/llm_file_description.py",
          "last_modified": "2024-12-04T14:46:09.864473",
          "should_be_recalculated": false,
          "public_interface": "\n# Keep all imports\nimport inspect\nfrom pydantic import BaseModel\nfrom vanilla.llm_executor import LLMExecutor\nfrom vanilla.execution_context import ExecutionContext\nfrom vanilla.llm import LLM_MODEL\nimport re\nfrom vanilla.llm_tag import LLMTag\n\nclass FileDescriptionResult(BaseModel):\n    \"\"\"\n    Represents the result of extracting a public interface and its description.\n    \n    Attributes:\n        public_interface: A string representation of the public interface.\n        description: A string description of the file.\n    \"\"\"\n    public_interface: str\n    description: str\n\nclass FileDescriptionLLMProcessor:\n    \"\"\"\n    Processor for extracting public interface information from code files using LLM.\n    \n    Attributes:\n        llm_executor: An instance of LLMExecutor used for generating responses.\n    \"\"\"\n\n    def __init__(self, llm_executor: LLMExecutor) -> None:\n        \"\"\"\n        Initializes the FileDescriptionLLMProcessor with an LLMExecutor.\n        \n        Args:\n            llm_executor: An instance of LLMExecutor to be used for LLM operations.\n        \"\"\"\n        self.llm_executor = llm_executor\n\n    def extract_public_interface_and_description(self, file_content: str, file_path: str) -> FileDescriptionResult:\n        \"\"\"\n        Extract public interface information from file content using LLM.\n        \n        Args:\n            file_content: The content of the file to analyze.\n            file_path: The path of the file being analyzed.\n            \n        Returns:\n            A FileDescriptionResult containing the public interface and description.\n        \"\"\"\n        pass  # Implementation details omitted\n",
          "description": "\nThis file contains classes and methods for extracting the public interface and description from code files using a language model. The `FileDescriptionResult` class is a data model for holding the results, while the `FileDescriptionLLMProcessor` class provides functionality to analyze code and return the public interface and description.\n",
          "file_size": 4147,
          "file_hash": "db5f6e2f537df05102152191456d43e4aead9851ace57e91aa3632aab6b227d5",
          "full_path": "/Users/martinsumera/projects/ai/kmp_coder/vanilla/code_search/llm/llm_file_description.py",
          "extension": "py"
        },
        {
          "name": "__init__.py",
          "path": "/Users/martinsumera/projects/ai/kmp_coder/vanilla/code_search/llm/__init__.py",
          "last_modified": "2024-12-03T14:55:51.072857",
          "should_be_recalculated": false,
          "public_interface": "\n# Keep all imports\nfrom typing import List, Optional\n\nclass CodeSearcher:\n    \"\"\"\n    A class to perform code searching operations.\n    \n    Attributes:\n        search_path (str): The path where the search will be conducted.\n    \"\"\"\n    \n    def __init__(self, search_path: str):\n        \"\"\"\n        Initializes the CodeSearcher with a specific search path.\n        \n        Args:\n            search_path: The directory path to search for code.\n        \"\"\"\n        pass  # Implementation details omitted\n\n    def search(self, query: str) -> List[str]:\n        \"\"\"\n        Searches for the given query in the specified search path.\n        \n        Args:\n            query: The search term to look for in the code files.\n            \n        Returns:\n            A list of file paths where the query was found.\n        \"\"\"\n        pass  # Implementation details omitted\n\n    def get_results(self) -> List[str]:\n        \"\"\"\n        Retrieves the results of the last search.\n        \n        Returns:\n            A list of results from the last search operation.\n        \"\"\"\n        pass  # Implementation details omitted\n\n# Global variables/constants (if any)\nDEFAULT_SEARCH_PATH: str = \"/usr/local/src\"  # Default path for searching code\n",
          "description": "\nThis file contains the implementation of a code searching utility. It provides a class `CodeSearcher` that allows users to search for specific queries within a designated directory. The public interface includes methods for initializing the searcher, performing searches, and retrieving results. Additionally, a default search path constant is defined for convenience.\n",
          "file_size": 0,
          "file_hash": "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
          "full_path": "/Users/martinsumera/projects/ai/kmp_coder/vanilla/code_search/llm/__init__.py",
          "extension": "py"
        }
      ],
      "directories": [],
      "_type": "DirectoryNode"
    },
    {
      "name": "file_system_nodes.py",
      "path": "/Users/martinsumera/projects/ai/kmp_coder/vanilla/code_search/file_system_nodes.py",
      "last_modified": "2024-12-04T11:16:18.268821",
      "public_interface": "\n# Keep all imports\nfrom pathlib import Path\nfrom typing import List\nfrom pydantic import BaseModel, computed_field\nfrom datetime import datetime\n\nclass FileSystemNode(BaseModel):\n    \"\"\"\n    Represents a node in the file system, which can be a file or a directory.\n    \n    Attributes:\n        name: The name of the file or directory.\n        path: The path to the file or directory.\n        last_modified: The last modified date of the file or directory.\n        should_be_recalculated: Indicates if the node should be recalculated.\n        public_interface: A string representing the public interface.\n        description: A description of the node.\n    \"\"\"\n    name: str\n    path: Path\n    last_modified: datetime\n    should_be_recalculated: Optional[bool] = None\n    public_interface: Optional[str] = None\n    description: Optional[str] = None\n\n    @computed_field\n    @property\n    def full_path(self) -> str:\n        \"\"\"\n        Returns the absolute path of the file or directory.\n        \n        Returns:\n            The absolute path as a string.\n        \"\"\"\n        pass  # Implementation details omitted\n\nclass FileNode(FileSystemNode):\n    \"\"\"\n    Represents a file in the file system.\n    \n    Attributes:\n        file_size: The size of the file in bytes.\n        file_hash: The hash of the file for integrity checks.\n    \"\"\"\n    file_size: int\n    file_hash: str\n\n    @computed_field\n    @property\n    def extension(self) -> str:\n        \"\"\"\n        Returns the file extension of the file.\n        \n        Returns:\n            The file extension as a string, or None if no extension exists.\n        \"\"\"\n        pass  # Implementation details omitted\n\nclass DirectoryNode(FileSystemNode):\n    \"\"\"\n    Represents a directory in the file system, which can contain files and subdirectories.\n    \n    Attributes:\n        children: A list of child FileSystemNode objects (files and directories).\n    \"\"\"\n    children: List[FileSystemNode] = []\n\n    @computed_field\n    @property\n    def files(self) -> List[FileNode]:\n        \"\"\"\n        Returns a list of FileNode objects contained in the directory.\n        \n        Returns:\n            A list of FileNode objects.\n        \"\"\"\n        pass  # Implementation details omitted\n    \n    @computed_field\n    @property\n    def directories(self) -> List['DirectoryNode']:\n        \"\"\"\n        Returns a list of DirectoryNode objects contained in the directory.\n        \n        Returns:\n            A list of DirectoryNode objects.\n        \"\"\"\n        pass  # Implementation details omitted\n\nclass FileSystemTree(BaseModel):\n    \"\"\"\n    Represents the entire file system tree starting from a root directory.\n    \n    Attributes:\n        root: The root directory of the file system tree.\n    \"\"\"\n    root: DirectoryNode\n\n    @computed_field\n    @property\n    def all_files(self) -> List[FileNode]:\n        \"\"\"\n        Collects all files in the file system tree recursively.\n        \n        Returns:\n            A list of all FileNode objects in the tree.\n        \"\"\"\n        pass  # Implementation details omitted\n\n# Global variables/constants (if any)\n",
      "description": "\nThis file defines a structure for representing a file system, including files and directories. It provides classes for file system nodes, file nodes, directory nodes, and the overall file system tree. Each class includes properties and methods for accessing relevant information about the file system structure.\n",
      "file_size": 1545,
      "file_hash": "b10392b68cc138058b19264f4c99f31784a40e48addcf7a5e2ea75e99f0f7bcc",
      "full_path": "/Users/martinsumera/projects/ai/kmp_coder/vanilla/code_search/file_system_nodes.py",
      "extension": "py",
      "_type": "FileNode"
    },
    {
      "name": "code_search_tree_processor.py",
      "path": "/Users/martinsumera/projects/ai/kmp_coder/vanilla/code_search/code_search_tree_processor.py",
      "last_modified": "2024-12-04T12:12:34.556459",
      "public_interface": "\n# Keep all imports\nfrom pathlib import Path\nfrom typing import Optional\nfrom vanilla.code_search.file_system_nodes import FileSystemNode, DirectoryNode, FileNode, FileSystemTree\nfrom vanilla.code_search.llm.llm_directory_description import DirectoryDescriptionLLMProcessor\nfrom vanilla.code_search.llm.llm_file_description import FileDescriptionLLMProcessor\n\nclass CodeSearchTreeProcessor:\n    \"\"\"\n    A processor for handling code search trees, generating descriptions for files and directories.\n    \n    Attributes:\n        llm_file_processor: An instance of FileDescriptionLLMProcessor for processing file descriptions.\n        llm_directory_processor: An instance of DirectoryDescriptionLLMProcessor for processing directory descriptions.\n    \"\"\"\n    \n    def __init__(\n        self,\n        llm_file_processor: FileDescriptionLLMProcessor,\n        llm_directory_processor: DirectoryDescriptionLLMProcessor,\n    ) -> None:\n        \"\"\"\n        Initializes the CodeSearchTreeProcessor with the specified LLM processors.\n        \n        Args:\n            llm_file_processor: The processor for file descriptions.\n            llm_directory_processor: The processor for directory descriptions.\n        \"\"\"\n        pass  # Implementation details omitted\n\n    def process_tree(self, tree: FileSystemTree) -> None:\n        \"\"\"\n        Processes the entire file system tree, generating descriptions for all nodes.\n        \n        Args:\n            tree: The root of the file system tree to be processed.\n        \"\"\"\n        pass  # Implementation details omitted\n\n# Global variables/constants (if any)\n",
      "description": "\nThis file contains the CodeSearchTreeProcessor class, which is responsible for processing a file system tree and generating descriptions for files and directories using LLM processors. The public interface includes the constructor and the method to process the tree.\n",
      "file_size": 2348,
      "file_hash": "9089bb8422ffa635e3d7957c7afd1a0713d9010415a747d83bded12d4e94ec7d",
      "full_path": "/Users/martinsumera/projects/ai/kmp_coder/vanilla/code_search/code_search_tree_processor.py",
      "extension": "py",
      "_type": "FileNode"
    },
    {
      "name": "__init__.py",
      "path": "/Users/martinsumera/projects/ai/kmp_coder/vanilla/code_search/__init__.py",
      "last_modified": "2024-12-03T11:09:44.850976",
      "public_interface": "\n# Keep all imports\nfrom typing import List, Optional\n\nclass CodeSearcher:\n    \"\"\"\n    A class to perform code searching operations.\n    \n    Attributes:\n        search_path (str): The path where the search will be conducted.\n    \"\"\"\n    \n    def __init__(self, search_path: str):\n        \"\"\"\n        Initializes the CodeSearcher with a specific search path.\n        \n        Args:\n            search_path: The directory path to search for code files.\n        \"\"\"\n        pass  # Implementation details omitted\n\n    def search(self, query: str) -> List[str]:\n        \"\"\"\n        Searches for the given query in the specified search path.\n        \n        Args:\n            query: The search term to look for in the code files.\n            \n        Returns:\n            A list of file paths where the query was found.\n        \"\"\"\n        pass  # Implementation details omitted\n\n    def get_results(self) -> List[str]:\n        \"\"\"\n        Retrieves the results of the last search.\n        \n        Returns:\n            A list of results from the last search operation.\n        \"\"\"\n        pass  # Implementation details omitted\n\n# Global variables/constants (if any)\nDEFAULT_SEARCH_PATH: str = \"/usr/local/src\"  # Default path for searching code\n",
      "description": "\nThis file contains the CodeSearcher class, which is designed to facilitate searching through code files in a specified directory. It includes methods for initializing the searcher, performing searches, and retrieving results. The DEFAULT_SEARCH_PATH constant provides a default directory for search operations.\n",
      "file_size": 0,
      "file_hash": "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
      "full_path": "/Users/martinsumera/projects/ai/kmp_coder/vanilla/code_search/__init__.py",
      "extension": "py",
      "_type": "FileNode"
    },
    {
      "name": "code_search_persistence.py",
      "path": "/Users/martinsumera/projects/ai/kmp_coder/vanilla/code_search/code_search_persistence.py",
      "last_modified": "2024-12-04T10:38:37.353538",
      "public_interface": "\n# Keep all imports\nfrom pathlib import Path\nimport json\nfrom typing import Dict, Any, Optional\nfrom datetime import datetime\n\nfrom vanilla.code_search.file_system_nodes import FileSystemNode, DirectoryNode, FileNode, FileSystemTree\n\nclass CodeSearchPersistence:\n    \"\"\"\n    Class responsible for persisting and loading file tree structures to and from JSON files.\n    \"\"\"\n\n    @staticmethod\n    def save_tree(tree: FileSystemTree, output_file: Path) -> None:\n        \"\"\"\n        Save the file tree structure to a JSON file.\n        \n        Args:\n            tree: Root node of the file tree.\n            output_file: Path where to save the JSON file.\n        \"\"\"\n        pass  # Implementation details omitted\n\n    @staticmethod\n    def try_load_tree(input_file: Path) -> Optional[FileSystemTree]:\n        \"\"\"\n        Load the file tree structure from a JSON file.\n        \n        Args:\n            input_file: Path to the JSON file containing the tree structure.\n            \n        Returns:\n            Reconstructed file tree with FileSystemNode as root, or None if the file does not exist.\n        \"\"\"\n        pass  # Implementation details omitted\n",
      "description": "\nThis file contains the CodeSearchPersistence class, which provides functionality to save and load file tree structures in JSON format. The public methods allow users to persist a file system tree to a file and reconstruct it from a file, facilitating easy storage and retrieval of file system data.\n",
      "file_size": 2941,
      "file_hash": "75d027f89f5be32f8555b716d5178b243e2c8e319d98b3bfd6ba9a1598bb4a03",
      "full_path": "/Users/martinsumera/projects/ai/kmp_coder/vanilla/code_search/code_search_persistence.py",
      "extension": "py",
      "_type": "FileNode"
    },
    {
      "name": "code_search_tree_creator.py",
      "path": "/Users/martinsumera/projects/ai/kmp_coder/vanilla/code_search/code_search_tree_creator.py",
      "last_modified": "2024-12-04T17:02:52.995283",
      "public_interface": "\n# Keep all imports\nfrom pathlib import Path\nfrom typing import List, Optional, Dict\nfrom vanilla.code_search.file_system_nodes import FileSystemNode, DirectoryNode, FileNode, FileSystemTree\n\nclass CodeSearchTreeCreator:\n    \"\"\"\n    Class responsible for creating and managing a file system tree structure.\n    \"\"\"\n\n    def build_file_tree(\n        self,\n        directory: Path,\n        include_patterns: List[str] = [\"*\"],\n        exclude_patterns: List[str] = [\".git\", \"__pycache__\", \"*.pyc\"]\n    ) -> FileSystemTree:\n        \"\"\"\n        Build a file system tree from the specified directory.\n\n        Args:\n            directory: Root directory to start scanning.\n            include_patterns: List of glob patterns to include (e.g., [\"*.py\", \"*.kt\"]).\n            exclude_patterns: List of glob patterns to exclude.\n\n        Returns:\n            A FileSystemTree representing the directory structure.\n        \"\"\"\n        pass  # Implementation details omitted\n\n    def compare_trees_and_mark_recalculation(\n        self,\n        old_tree: FileSystemTree,\n        new_tree: FileSystemTree,\n    ) -> None:\n        \"\"\"\n        Compare two file trees and set should_be_recalculated flag on new_tree nodes based on changes.\n\n        Args:\n            old_tree: The old file system tree.\n            new_tree: The new file system tree to compare against.\n        \"\"\"\n        pass  # Implementation details omitted\n\n    def mark_all_for_recalculation(self, tree: FileSystemTree) -> None:\n        \"\"\"Mark all nodes in the tree for recalculation.\n\n        Args:\n            tree: The file system tree to mark.\n        \"\"\"\n        pass  # Implementation details omitted\n",
      "description": "\nThis file contains the `CodeSearchTreeCreator` class, which is responsible for building and managing a file system tree structure. It provides methods to build a tree from a directory, compare two trees, and mark all nodes for recalculation. The class utilizes file system nodes to represent directories and files, and it supports pattern matching for including and excluding files during tree creation.\n",
      "file_size": 7067,
      "file_hash": "39f890c54c98699237a385789d414d7404791d44e94491aa6fa922f79e4a0050",
      "full_path": "/Users/martinsumera/projects/ai/kmp_coder/vanilla/code_search/code_search_tree_creator.py",
      "extension": "py",
      "_type": "FileNode"
    },
    {
      "name": "code_search.py",
      "path": "/Users/martinsumera/projects/ai/kmp_coder/vanilla/code_search/code_search.py",
      "last_modified": "2024-12-04T17:01:35.605123",
      "public_interface": "\n# Keep all imports\nfrom pathlib import Path\nfrom typing import List, Optional\n\nfrom pydantic import BaseModel\n\nclass CodeSearchResult(BaseModel):\n    \"\"\"\n    Represents the result of a code search.\n\n    Attributes:\n        file_path: The path to the file.\n        file_description: A description of the file.\n        file_public_interface: The public interface of the file.\n        relevance_score: The relevance score of the file based on the search query.\n        explanation: An explanation of the relevance score.\n    \"\"\"\n    file_path: Path\n    file_description: str\n    file_public_interface: str\n    relevance_score: float\n    explanation: str\n\nclass CodeSearch:\n    \"\"\"\n    A class to perform code searches within a project.\n\n    Attributes:\n        TREE_FILE_PATH: The path to the tree file used for code search.\n    \"\"\"\n    TREE_FILE_PATH = \".kmpcoder/code_search_tree.json\"\n\n    def __init__(\n        self,\n        tree_processor: CodeSearchTreeProcessor,\n        tree_builder: CodeSearchTreeCreator,\n        llm_file_relevancy: FileRelevancyLLMProcessor,\n        persistence: CodeSearchPersistence,\n        project_context: ProjectContext,\n    ):\n        \"\"\"\n        Initializes the CodeSearch instance.\n\n        Args:\n            tree_processor: An instance of CodeSearchTreeProcessor.\n            tree_builder: An instance of CodeSearchTreeCreator.\n            llm_file_relevancy: An instance of FileRelevancyLLMProcessor.\n            persistence: An instance of CodeSearchPersistence.\n            project_context: An instance of ProjectContext.\n        \"\"\"\n        pass  # Implementation details omitted\n\n    def perform_search(\n        self,\n        query: str,\n        max_files: int,\n        select_all_high_relevant_files: bool,\n        context: ExecutionContext,\n    ) -> List[CodeSearchResult]:\n        \"\"\"\n        Performs a search for relevant code files based on the provided query.\n\n        Args:\n            query: The search query string.\n            max_files: The maximum number of files to return.\n            select_all_high_relevant_files: Whether to select all files with high relevance.\n            context: The execution context for the search.\n\n        Returns:\n            A list of CodeSearchResult containing the search results.\n        \"\"\"\n        pass  # Implementation details omitted\n\n# Global variables/constants (if any)\n# No global variables/constants to include\n",
      "description": "\nThis file contains the CodeSearch class, which is responsible for performing code searches within a project. It utilizes various components for processing and evaluating code files based on relevance to a search query. The CodeSearchResult class is used to encapsulate the results of a search, providing details about each file found. The public interface includes the constructor and the perform_search method, which are essential for using the CodeSearch functionality.\n",
      "file_size": 5478,
      "file_hash": "0bc47f129f52a9a3ddcf18a54aa96b9d8e3db6e4d031707992f513d6cea2abd2",
      "full_path": "/Users/martinsumera/projects/ai/kmp_coder/vanilla/code_search/code_search.py",
      "extension": "py",
      "_type": "FileNode"
    }
  ],
  "full_path": "/Users/martinsumera/projects/ai/kmp_coder/vanilla/code_search",
  "files": [
    {
      "name": "file_system_nodes.py",
      "path": "/Users/martinsumera/projects/ai/kmp_coder/vanilla/code_search/file_system_nodes.py",
      "last_modified": "2024-12-04T11:16:18.268821",
      "should_be_recalculated": false,
      "public_interface": "\n# Keep all imports\nfrom pathlib import Path\nfrom typing import List\nfrom pydantic import BaseModel, computed_field\nfrom datetime import datetime\n\nclass FileSystemNode(BaseModel):\n    \"\"\"\n    Represents a node in the file system, which can be a file or a directory.\n    \n    Attributes:\n        name: The name of the file or directory.\n        path: The path to the file or directory.\n        last_modified: The last modified date of the file or directory.\n        should_be_recalculated: Indicates if the node should be recalculated.\n        public_interface: A string representing the public interface.\n        description: A description of the node.\n    \"\"\"\n    name: str\n    path: Path\n    last_modified: datetime\n    should_be_recalculated: Optional[bool] = None\n    public_interface: Optional[str] = None\n    description: Optional[str] = None\n\n    @computed_field\n    @property\n    def full_path(self) -> str:\n        \"\"\"\n        Returns the absolute path of the file or directory.\n        \n        Returns:\n            The absolute path as a string.\n        \"\"\"\n        pass  # Implementation details omitted\n\nclass FileNode(FileSystemNode):\n    \"\"\"\n    Represents a file in the file system.\n    \n    Attributes:\n        file_size: The size of the file in bytes.\n        file_hash: The hash of the file for integrity checks.\n    \"\"\"\n    file_size: int\n    file_hash: str\n\n    @computed_field\n    @property\n    def extension(self) -> str:\n        \"\"\"\n        Returns the file extension of the file.\n        \n        Returns:\n            The file extension as a string, or None if no extension exists.\n        \"\"\"\n        pass  # Implementation details omitted\n\nclass DirectoryNode(FileSystemNode):\n    \"\"\"\n    Represents a directory in the file system, which can contain files and subdirectories.\n    \n    Attributes:\n        children: A list of child FileSystemNode objects (files and directories).\n    \"\"\"\n    children: List[FileSystemNode] = []\n\n    @computed_field\n    @property\n    def files(self) -> List[FileNode]:\n        \"\"\"\n        Returns a list of FileNode objects contained in the directory.\n        \n        Returns:\n            A list of FileNode objects.\n        \"\"\"\n        pass  # Implementation details omitted\n    \n    @computed_field\n    @property\n    def directories(self) -> List['DirectoryNode']:\n        \"\"\"\n        Returns a list of DirectoryNode objects contained in the directory.\n        \n        Returns:\n            A list of DirectoryNode objects.\n        \"\"\"\n        pass  # Implementation details omitted\n\nclass FileSystemTree(BaseModel):\n    \"\"\"\n    Represents the entire file system tree starting from a root directory.\n    \n    Attributes:\n        root: The root directory of the file system tree.\n    \"\"\"\n    root: DirectoryNode\n\n    @computed_field\n    @property\n    def all_files(self) -> List[FileNode]:\n        \"\"\"\n        Collects all files in the file system tree recursively.\n        \n        Returns:\n            A list of all FileNode objects in the tree.\n        \"\"\"\n        pass  # Implementation details omitted\n\n# Global variables/constants (if any)\n",
      "description": "\nThis file defines a structure for representing a file system, including files and directories. It provides classes for file system nodes, file nodes, directory nodes, and the overall file system tree. Each class includes properties and methods for accessing relevant information about the file system structure.\n",
      "file_size": 1545,
      "file_hash": "b10392b68cc138058b19264f4c99f31784a40e48addcf7a5e2ea75e99f0f7bcc",
      "full_path": "/Users/martinsumera/projects/ai/kmp_coder/vanilla/code_search/file_system_nodes.py",
      "extension": "py"
    },
    {
      "name": "code_search_tree_processor.py",
      "path": "/Users/martinsumera/projects/ai/kmp_coder/vanilla/code_search/code_search_tree_processor.py",
      "last_modified": "2024-12-04T12:12:34.556459",
      "should_be_recalculated": false,
      "public_interface": "\n# Keep all imports\nfrom pathlib import Path\nfrom typing import Optional\nfrom vanilla.code_search.file_system_nodes import FileSystemNode, DirectoryNode, FileNode, FileSystemTree\nfrom vanilla.code_search.llm.llm_directory_description import DirectoryDescriptionLLMProcessor\nfrom vanilla.code_search.llm.llm_file_description import FileDescriptionLLMProcessor\n\nclass CodeSearchTreeProcessor:\n    \"\"\"\n    A processor for handling code search trees, generating descriptions for files and directories.\n    \n    Attributes:\n        llm_file_processor: An instance of FileDescriptionLLMProcessor for processing file descriptions.\n        llm_directory_processor: An instance of DirectoryDescriptionLLMProcessor for processing directory descriptions.\n    \"\"\"\n    \n    def __init__(\n        self,\n        llm_file_processor: FileDescriptionLLMProcessor,\n        llm_directory_processor: DirectoryDescriptionLLMProcessor,\n    ) -> None:\n        \"\"\"\n        Initializes the CodeSearchTreeProcessor with the specified LLM processors.\n        \n        Args:\n            llm_file_processor: The processor for file descriptions.\n            llm_directory_processor: The processor for directory descriptions.\n        \"\"\"\n        pass  # Implementation details omitted\n\n    def process_tree(self, tree: FileSystemTree) -> None:\n        \"\"\"\n        Processes the entire file system tree, generating descriptions for all nodes.\n        \n        Args:\n            tree: The root of the file system tree to be processed.\n        \"\"\"\n        pass  # Implementation details omitted\n\n# Global variables/constants (if any)\n",
      "description": "\nThis file contains the CodeSearchTreeProcessor class, which is responsible for processing a file system tree and generating descriptions for files and directories using LLM processors. The public interface includes the constructor and the method to process the tree.\n",
      "file_size": 2348,
      "file_hash": "9089bb8422ffa635e3d7957c7afd1a0713d9010415a747d83bded12d4e94ec7d",
      "full_path": "/Users/martinsumera/projects/ai/kmp_coder/vanilla/code_search/code_search_tree_processor.py",
      "extension": "py"
    },
    {
      "name": "__init__.py",
      "path": "/Users/martinsumera/projects/ai/kmp_coder/vanilla/code_search/__init__.py",
      "last_modified": "2024-12-03T11:09:44.850976",
      "should_be_recalculated": false,
      "public_interface": "\n# Keep all imports\nfrom typing import List, Optional\n\nclass CodeSearcher:\n    \"\"\"\n    A class to perform code searching operations.\n    \n    Attributes:\n        search_path (str): The path where the search will be conducted.\n    \"\"\"\n    \n    def __init__(self, search_path: str):\n        \"\"\"\n        Initializes the CodeSearcher with a specific search path.\n        \n        Args:\n            search_path: The directory path to search for code files.\n        \"\"\"\n        pass  # Implementation details omitted\n\n    def search(self, query: str) -> List[str]:\n        \"\"\"\n        Searches for the given query in the specified search path.\n        \n        Args:\n            query: The search term to look for in the code files.\n            \n        Returns:\n            A list of file paths where the query was found.\n        \"\"\"\n        pass  # Implementation details omitted\n\n    def get_results(self) -> List[str]:\n        \"\"\"\n        Retrieves the results of the last search.\n        \n        Returns:\n            A list of results from the last search operation.\n        \"\"\"\n        pass  # Implementation details omitted\n\n# Global variables/constants (if any)\nDEFAULT_SEARCH_PATH: str = \"/usr/local/src\"  # Default path for searching code\n",
      "description": "\nThis file contains the CodeSearcher class, which is designed to facilitate searching through code files in a specified directory. It includes methods for initializing the searcher, performing searches, and retrieving results. The DEFAULT_SEARCH_PATH constant provides a default directory for search operations.\n",
      "file_size": 0,
      "file_hash": "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
      "full_path": "/Users/martinsumera/projects/ai/kmp_coder/vanilla/code_search/__init__.py",
      "extension": "py"
    },
    {
      "name": "code_search_persistence.py",
      "path": "/Users/martinsumera/projects/ai/kmp_coder/vanilla/code_search/code_search_persistence.py",
      "last_modified": "2024-12-04T10:38:37.353538",
      "should_be_recalculated": false,
      "public_interface": "\n# Keep all imports\nfrom pathlib import Path\nimport json\nfrom typing import Dict, Any, Optional\nfrom datetime import datetime\n\nfrom vanilla.code_search.file_system_nodes import FileSystemNode, DirectoryNode, FileNode, FileSystemTree\n\nclass CodeSearchPersistence:\n    \"\"\"\n    Class responsible for persisting and loading file tree structures to and from JSON files.\n    \"\"\"\n\n    @staticmethod\n    def save_tree(tree: FileSystemTree, output_file: Path) -> None:\n        \"\"\"\n        Save the file tree structure to a JSON file.\n        \n        Args:\n            tree: Root node of the file tree.\n            output_file: Path where to save the JSON file.\n        \"\"\"\n        pass  # Implementation details omitted\n\n    @staticmethod\n    def try_load_tree(input_file: Path) -> Optional[FileSystemTree]:\n        \"\"\"\n        Load the file tree structure from a JSON file.\n        \n        Args:\n            input_file: Path to the JSON file containing the tree structure.\n            \n        Returns:\n            Reconstructed file tree with FileSystemNode as root, or None if the file does not exist.\n        \"\"\"\n        pass  # Implementation details omitted\n",
      "description": "\nThis file contains the CodeSearchPersistence class, which provides functionality to save and load file tree structures in JSON format. The public methods allow users to persist a file system tree to a file and reconstruct it from a file, facilitating easy storage and retrieval of file system data.\n",
      "file_size": 2941,
      "file_hash": "75d027f89f5be32f8555b716d5178b243e2c8e319d98b3bfd6ba9a1598bb4a03",
      "full_path": "/Users/martinsumera/projects/ai/kmp_coder/vanilla/code_search/code_search_persistence.py",
      "extension": "py"
    },
    {
      "name": "code_search_tree_creator.py",
      "path": "/Users/martinsumera/projects/ai/kmp_coder/vanilla/code_search/code_search_tree_creator.py",
      "last_modified": "2024-12-04T17:02:52.995283",
      "should_be_recalculated": false,
      "public_interface": "\n# Keep all imports\nfrom pathlib import Path\nfrom typing import List, Optional, Dict\nfrom vanilla.code_search.file_system_nodes import FileSystemNode, DirectoryNode, FileNode, FileSystemTree\n\nclass CodeSearchTreeCreator:\n    \"\"\"\n    Class responsible for creating and managing a file system tree structure.\n    \"\"\"\n\n    def build_file_tree(\n        self,\n        directory: Path,\n        include_patterns: List[str] = [\"*\"],\n        exclude_patterns: List[str] = [\".git\", \"__pycache__\", \"*.pyc\"]\n    ) -> FileSystemTree:\n        \"\"\"\n        Build a file system tree from the specified directory.\n\n        Args:\n            directory: Root directory to start scanning.\n            include_patterns: List of glob patterns to include (e.g., [\"*.py\", \"*.kt\"]).\n            exclude_patterns: List of glob patterns to exclude.\n\n        Returns:\n            A FileSystemTree representing the directory structure.\n        \"\"\"\n        pass  # Implementation details omitted\n\n    def compare_trees_and_mark_recalculation(\n        self,\n        old_tree: FileSystemTree,\n        new_tree: FileSystemTree,\n    ) -> None:\n        \"\"\"\n        Compare two file trees and set should_be_recalculated flag on new_tree nodes based on changes.\n\n        Args:\n            old_tree: The old file system tree.\n            new_tree: The new file system tree to compare against.\n        \"\"\"\n        pass  # Implementation details omitted\n\n    def mark_all_for_recalculation(self, tree: FileSystemTree) -> None:\n        \"\"\"Mark all nodes in the tree for recalculation.\n\n        Args:\n            tree: The file system tree to mark.\n        \"\"\"\n        pass  # Implementation details omitted\n",
      "description": "\nThis file contains the `CodeSearchTreeCreator` class, which is responsible for building and managing a file system tree structure. It provides methods to build a tree from a directory, compare two trees, and mark all nodes for recalculation. The class utilizes file system nodes to represent directories and files, and it supports pattern matching for including and excluding files during tree creation.\n",
      "file_size": 7067,
      "file_hash": "39f890c54c98699237a385789d414d7404791d44e94491aa6fa922f79e4a0050",
      "full_path": "/Users/martinsumera/projects/ai/kmp_coder/vanilla/code_search/code_search_tree_creator.py",
      "extension": "py"
    },
    {
      "name": "code_search.py",
      "path": "/Users/martinsumera/projects/ai/kmp_coder/vanilla/code_search/code_search.py",
      "last_modified": "2024-12-04T17:01:35.605123",
      "should_be_recalculated": false,
      "public_interface": "\n# Keep all imports\nfrom pathlib import Path\nfrom typing import List, Optional\n\nfrom pydantic import BaseModel\n\nclass CodeSearchResult(BaseModel):\n    \"\"\"\n    Represents the result of a code search.\n\n    Attributes:\n        file_path: The path to the file.\n        file_description: A description of the file.\n        file_public_interface: The public interface of the file.\n        relevance_score: The relevance score of the file based on the search query.\n        explanation: An explanation of the relevance score.\n    \"\"\"\n    file_path: Path\n    file_description: str\n    file_public_interface: str\n    relevance_score: float\n    explanation: str\n\nclass CodeSearch:\n    \"\"\"\n    A class to perform code searches within a project.\n\n    Attributes:\n        TREE_FILE_PATH: The path to the tree file used for code search.\n    \"\"\"\n    TREE_FILE_PATH = \".kmpcoder/code_search_tree.json\"\n\n    def __init__(\n        self,\n        tree_processor: CodeSearchTreeProcessor,\n        tree_builder: CodeSearchTreeCreator,\n        llm_file_relevancy: FileRelevancyLLMProcessor,\n        persistence: CodeSearchPersistence,\n        project_context: ProjectContext,\n    ):\n        \"\"\"\n        Initializes the CodeSearch instance.\n\n        Args:\n            tree_processor: An instance of CodeSearchTreeProcessor.\n            tree_builder: An instance of CodeSearchTreeCreator.\n            llm_file_relevancy: An instance of FileRelevancyLLMProcessor.\n            persistence: An instance of CodeSearchPersistence.\n            project_context: An instance of ProjectContext.\n        \"\"\"\n        pass  # Implementation details omitted\n\n    def perform_search(\n        self,\n        query: str,\n        max_files: int,\n        select_all_high_relevant_files: bool,\n        context: ExecutionContext,\n    ) -> List[CodeSearchResult]:\n        \"\"\"\n        Performs a search for relevant code files based on the provided query.\n\n        Args:\n            query: The search query string.\n            max_files: The maximum number of files to return.\n            select_all_high_relevant_files: Whether to select all files with high relevance.\n            context: The execution context for the search.\n\n        Returns:\n            A list of CodeSearchResult containing the search results.\n        \"\"\"\n        pass  # Implementation details omitted\n\n# Global variables/constants (if any)\n# No global variables/constants to include\n",
      "description": "\nThis file contains the CodeSearch class, which is responsible for performing code searches within a project. It utilizes various components for processing and evaluating code files based on relevance to a search query. The CodeSearchResult class is used to encapsulate the results of a search, providing details about each file found. The public interface includes the constructor and the perform_search method, which are essential for using the CodeSearch functionality.\n",
      "file_size": 5478,
      "file_hash": "0bc47f129f52a9a3ddcf18a54aa96b9d8e3db6e4d031707992f513d6cea2abd2",
      "full_path": "/Users/martinsumera/projects/ai/kmp_coder/vanilla/code_search/code_search.py",
      "extension": "py"
    }
  ],
  "directories": [
    {
      "name": "llm",
      "path": "/Users/martinsumera/projects/ai/kmp_coder/vanilla/code_search/llm",
      "last_modified": "2024-12-03T15:35:41.402195",
      "should_be_recalculated": false,
      "public_interface": null,
      "description": "The `/Users/martinsumera/projects/ai/kmp_coder/vanilla/code_search/llm` directory is designed for processing and analyzing code files using language models (LLMs). It contains several Python files that work together to provide functionalities for determining file relevancy and extracting descriptions from code.\n\n1. **llm_file_relevancy.py**: This file implements the `FileRelevancyLLMProcessor` class, which analyzes multiple files asynchronously to determine their relevancy based on a given query. It includes the `FileRelevancyResult` data model to structure the relevancy results.\n\n2. **llm_file_description.py**: This file focuses on extracting the public interface and descriptions from code files. It contains the `FileDescriptionLLMProcessor` class, which utilizes the `FileDescriptionResult` data model to hold the results of the analysis.\n\n3. **__init__.py**: This file serves as a utility for searching code within a specified directory. It provides the `CodeSearcher` class, which includes methods for initializing searches, executing them, and retrieving results. A default search path constant is also defined for ease of use.\n\nThe directory follows a modular design pattern, where each file encapsulates specific functionalities related to LLM processing. The use of clear class and method names enhances readability and maintainability, making it easier for developers to understand and extend the system.",
      "children": [
        {
          "name": "llm_file_relevancy.py",
          "path": "/Users/martinsumera/projects/ai/kmp_coder/vanilla/code_search/llm/llm_file_relevancy.py",
          "last_modified": "2024-12-04T15:01:32.218578",
          "should_be_recalculated": false,
          "public_interface": "\n# Keep all imports\nfrom pathlib import Path\nimport re\nfrom typing import List\nfrom pydantic import BaseModel\nfrom concurrent.futures import ThreadPoolExecutor\nimport asyncio\n\nfrom vanilla.code_search.file_system_nodes import FileNode\nfrom vanilla.execution_context import ExecutionContext\nfrom vanilla.llm import LLM_MODEL\nfrom vanilla.llm_executor import LLMExecutor\nfrom vanilla.llm_tag import LLMTag\nfrom vanilla.utils.async_execution import AsyncExecution\n\nclass FileRelevancyResult(BaseModel):\n    \"\"\"\n    Represents the result of a file relevancy check.\n\n    Attributes:\n        file_path: The path of the file being analyzed.\n        is_relevant: A boolean indicating if the file is relevant to the query.\n        relevance_score: A float score representing the relevance of the file.\n        explanation: A string providing an explanation for the relevancy decision.\n    \"\"\"\n    file_path: Path\n    is_relevant: bool\n    relevance_score: float\n    explanation: str\n\nclass FileRelevancyLLMProcessor:\n    \"\"\"\n    Processor for determining the relevancy of files based on a query using LLM.\n\n    Attributes:\n        llm_executor: An instance of LLMExecutor for generating responses.\n        async_execution: An instance of AsyncExecution for handling asynchronous tasks.\n    \"\"\"\n    \n    def __init__(self, llm_executor: LLMExecutor, async_execution: AsyncExecution):\n        \"\"\"\n        Initializes the FileRelevancyLLMProcessor with the given LLMExecutor and AsyncExecution.\n\n        Args:\n            llm_executor: An instance of LLMExecutor.\n            async_execution: An instance of AsyncExecution.\n        \"\"\"\n        self.llm_executor = llm_executor\n        self.async_execution = async_execution\n\n    def determine_relevancy(\n        self,\n        query: str,\n        file_nodes: List[FileNode],\n        context: ExecutionContext,\n    ) -> List[FileRelevancyResult]:\n        \"\"\"\n        Determines the relevancy of multiple files for a given query.\n\n        Args:\n            query: The query string to analyze against the files.\n            file_nodes: A list of FileNode instances representing the files to check.\n            context: The execution context for the LLM.\n\n        Returns:\n            A list of FileRelevancyResult containing relevancy information for each file.\n        \"\"\"\n        args_list = [(query, file_node.path, context) for file_node in file_nodes]\n        return self.async_execution.run_async_tasks_in_executor(self._determine_relevancy_for_single_file, *args_list)\n\n# Global variables/constants (if any)\n_SYSTEM_PROMPT_FILE_RELEVANCY: str = \"\"\"\nYou are a code analyzer that determines the relevancy of a file based on a given query.\n\nYour task is to analyze the file content and decide if it is relevant to the query. Provide a relevance score between 0 and 1, and an explanation for your decision.\n\n1 - The file is totally irrelevant to the query and it is exactly what the query asks for.\n1..0.8 - The file is relevant to the query, but it is not exactly what the query asks for.\n0.8..0.5 - The file may be relevant to the query.\n0.5..0.3 - The file is probably not relevant to the query.\n0.3..0 - The file is not relevant to the query.\n\nRules:\n1. Consider the context of the query and the file content.\n2. Evaluate if the file contains elements related to the query.\n3. Provide a boolean indicating relevancy (true/false).\n4. Assign a relevance score (0 to 1) based on the strength of the match.\n5. Offer a clear explanation for your decision.\n\nFormat your response as follows:\n\n<answer>\n<reasoning>Reasoning why the file is relevant or not relevant to the query.</reasoning>\n<score>0.85</score>\n<is_relevant>true</is_relevant>\n</answer>\n\nRemember:\n- Be concise and clear in your explanation.\n- Use the relevance score to reflect the degree of match.\n- Ensure the response is well-structured and follows the format.\n\"\"\"\n",
          "description": "\nThis file contains the implementation of a processor that determines the relevancy of files based on a given query using a language model (LLM). It includes a data model for the relevancy results and a method to analyze multiple files asynchronously. The public interface consists of the `FileRelevancyResult` data model and the `FileRelevancyLLMProcessor` class with its constructor and the `determine_relevancy` method.\n",
          "full_path": "/Users/martinsumera/projects/ai/kmp_coder/vanilla/code_search/llm/llm_file_relevancy.py"
        },
        {
          "name": "llm_directory_description.py",
          "path": "/Users/martinsumera/projects/ai/kmp_coder/vanilla/code_search/llm/llm_directory_description.py",
          "last_modified": "2024-12-04T10:34:37.641666",
          "should_be_recalculated": false,
          "public_interface": "\n# Keep all imports\nfrom typing import List\nfrom pydantic import BaseModel\nfrom vanilla.code_search.file_system_nodes import DirectoryNode\nfrom vanilla.llm_executor import LLMExecutor\nfrom vanilla.execution_context import ExecutionContext\nfrom vanilla.llm import LLM_MODEL\nfrom vanilla.llm_tag import LLMTag\n\nclass DirectoryDescriptionResult(BaseModel):\n    \"\"\"\n    Represents the result of a directory description extraction.\n\n    Attributes:\n        description: A string containing the description of the directory.\n    \"\"\"\n    description: str\n\nclass DirectoryDescriptionLLMProcessor:\n    \"\"\"\n    Processor for extracting directory descriptions using a language model.\n\n    Attributes:\n        llm_executor: An instance of LLMExecutor used to generate descriptions.\n    \"\"\"\n    \n    def __init__(self, llm_executor: LLMExecutor) -> None:\n        \"\"\"\n        Initializes the DirectoryDescriptionLLMProcessor with an LLMExecutor.\n\n        Args:\n            llm_executor: An instance of LLMExecutor for generating descriptions.\n        \"\"\"\n        self.llm_executor = llm_executor\n\n    def extract_directory_description(self, directory_node: DirectoryNode) -> DirectoryDescriptionResult:\n        \"\"\"\n        Extract directory description including descriptions of all direct children (files and subdirectories).\n        \n        Raises:\n            ValueError: If any child description is missing.\n\n        Args:\n            directory_node: The DirectoryNode representing the directory to analyze.\n\n        Returns:\n            DirectoryDescriptionResult: The result containing the directory description.\n        \"\"\"\n        pass  # Implementation details omitted\n\n# Global variables/constants (if any)\n_SYSTEM_PROMPT: str = \"\"\"\nYou are a directory analyzer that creates comprehensive directory descriptions. You have background in software engineering and are able to understand the purpose of the code in the directory.\n\nYour task is to analyze a directory structure and create a clear description that explains:\n1. The overall purpose of the directory\n2. How the contents work together\n3. Any important patterns or conventions\n\nYour description will be used to help LLM agents understand the purpose of the directory and its contents. So make it descriptive and helpful.\n\nFormat your response as follows:\n\n<answer>\n<reasoning>\nA detailed explanation of your thought process for creating the description.\n</reasoning>\n<description>\nA clear, concise description of the directory that explains its purpose, contents, and how they work together.\nThe description should help developers understand what they can find in this directory and how it's organized.\n</description>\n</answer>\n\nRemember:\n- Focus on the directory's role in the larger system\n- Explain relationships between contained files/subdirectories\n- Highlight important patterns or conventions\n- Keep descriptions clear and concise\n\"\"\"\n",
          "description": "\nA clear, concise description of the directory that explains its purpose, contents, and how they work together.\nThe description should help developers understand what they can find in this directory and how it's organized.\n",
          "full_path": "/Users/martinsumera/projects/ai/kmp_coder/vanilla/code_search/llm/llm_directory_description.py"
        },
        {
          "name": "llm_file_description.py",
          "path": "/Users/martinsumera/projects/ai/kmp_coder/vanilla/code_search/llm/llm_file_description.py",
          "last_modified": "2024-12-04T14:46:09.864473",
          "should_be_recalculated": false,
          "public_interface": "\n# Keep all imports\nimport inspect\nfrom pydantic import BaseModel\nfrom vanilla.llm_executor import LLMExecutor\nfrom vanilla.execution_context import ExecutionContext\nfrom vanilla.llm import LLM_MODEL\nimport re\nfrom vanilla.llm_tag import LLMTag\n\nclass FileDescriptionResult(BaseModel):\n    \"\"\"\n    Represents the result of extracting a public interface and its description.\n    \n    Attributes:\n        public_interface: A string representation of the public interface.\n        description: A string description of the file.\n    \"\"\"\n    public_interface: str\n    description: str\n\nclass FileDescriptionLLMProcessor:\n    \"\"\"\n    Processor for extracting public interface information from code files using LLM.\n    \n    Attributes:\n        llm_executor: An instance of LLMExecutor used for generating responses.\n    \"\"\"\n\n    def __init__(self, llm_executor: LLMExecutor) -> None:\n        \"\"\"\n        Initializes the FileDescriptionLLMProcessor with an LLMExecutor.\n        \n        Args:\n            llm_executor: An instance of LLMExecutor to be used for LLM operations.\n        \"\"\"\n        self.llm_executor = llm_executor\n\n    def extract_public_interface_and_description(self, file_content: str, file_path: str) -> FileDescriptionResult:\n        \"\"\"\n        Extract public interface information from file content using LLM.\n        \n        Args:\n            file_content: The content of the file to analyze.\n            file_path: The path of the file being analyzed.\n            \n        Returns:\n            A FileDescriptionResult containing the public interface and description.\n        \"\"\"\n        pass  # Implementation details omitted\n",
          "description": "\nThis file contains classes and methods for extracting the public interface and description from code files using a language model. The `FileDescriptionResult` class is a data model for holding the results, while the `FileDescriptionLLMProcessor` class provides functionality to analyze code and return the public interface and description.\n",
          "full_path": "/Users/martinsumera/projects/ai/kmp_coder/vanilla/code_search/llm/llm_file_description.py"
        },
        {
          "name": "__init__.py",
          "path": "/Users/martinsumera/projects/ai/kmp_coder/vanilla/code_search/llm/__init__.py",
          "last_modified": "2024-12-03T14:55:51.072857",
          "should_be_recalculated": false,
          "public_interface": "\n# Keep all imports\nfrom typing import List, Optional\n\nclass CodeSearcher:\n    \"\"\"\n    A class to perform code searching operations.\n    \n    Attributes:\n        search_path (str): The path where the search will be conducted.\n    \"\"\"\n    \n    def __init__(self, search_path: str):\n        \"\"\"\n        Initializes the CodeSearcher with a specific search path.\n        \n        Args:\n            search_path: The directory path to search for code.\n        \"\"\"\n        pass  # Implementation details omitted\n\n    def search(self, query: str) -> List[str]:\n        \"\"\"\n        Searches for the given query in the specified search path.\n        \n        Args:\n            query: The search term to look for in the code files.\n            \n        Returns:\n            A list of file paths where the query was found.\n        \"\"\"\n        pass  # Implementation details omitted\n\n    def get_results(self) -> List[str]:\n        \"\"\"\n        Retrieves the results of the last search.\n        \n        Returns:\n            A list of results from the last search operation.\n        \"\"\"\n        pass  # Implementation details omitted\n\n# Global variables/constants (if any)\nDEFAULT_SEARCH_PATH: str = \"/usr/local/src\"  # Default path for searching code\n",
          "description": "\nThis file contains the implementation of a code searching utility. It provides a class `CodeSearcher` that allows users to search for specific queries within a designated directory. The public interface includes methods for initializing the searcher, performing searches, and retrieving results. Additionally, a default search path constant is defined for convenience.\n",
          "full_path": "/Users/martinsumera/projects/ai/kmp_coder/vanilla/code_search/llm/__init__.py"
        }
      ],
      "full_path": "/Users/martinsumera/projects/ai/kmp_coder/vanilla/code_search/llm",
      "files": [
        {
          "name": "llm_file_relevancy.py",
          "path": "/Users/martinsumera/projects/ai/kmp_coder/vanilla/code_search/llm/llm_file_relevancy.py",
          "last_modified": "2024-12-04T15:01:32.218578",
          "should_be_recalculated": false,
          "public_interface": "\n# Keep all imports\nfrom pathlib import Path\nimport re\nfrom typing import List\nfrom pydantic import BaseModel\nfrom concurrent.futures import ThreadPoolExecutor\nimport asyncio\n\nfrom vanilla.code_search.file_system_nodes import FileNode\nfrom vanilla.execution_context import ExecutionContext\nfrom vanilla.llm import LLM_MODEL\nfrom vanilla.llm_executor import LLMExecutor\nfrom vanilla.llm_tag import LLMTag\nfrom vanilla.utils.async_execution import AsyncExecution\n\nclass FileRelevancyResult(BaseModel):\n    \"\"\"\n    Represents the result of a file relevancy check.\n\n    Attributes:\n        file_path: The path of the file being analyzed.\n        is_relevant: A boolean indicating if the file is relevant to the query.\n        relevance_score: A float score representing the relevance of the file.\n        explanation: A string providing an explanation for the relevancy decision.\n    \"\"\"\n    file_path: Path\n    is_relevant: bool\n    relevance_score: float\n    explanation: str\n\nclass FileRelevancyLLMProcessor:\n    \"\"\"\n    Processor for determining the relevancy of files based on a query using LLM.\n\n    Attributes:\n        llm_executor: An instance of LLMExecutor for generating responses.\n        async_execution: An instance of AsyncExecution for handling asynchronous tasks.\n    \"\"\"\n    \n    def __init__(self, llm_executor: LLMExecutor, async_execution: AsyncExecution):\n        \"\"\"\n        Initializes the FileRelevancyLLMProcessor with the given LLMExecutor and AsyncExecution.\n\n        Args:\n            llm_executor: An instance of LLMExecutor.\n            async_execution: An instance of AsyncExecution.\n        \"\"\"\n        self.llm_executor = llm_executor\n        self.async_execution = async_execution\n\n    def determine_relevancy(\n        self,\n        query: str,\n        file_nodes: List[FileNode],\n        context: ExecutionContext,\n    ) -> List[FileRelevancyResult]:\n        \"\"\"\n        Determines the relevancy of multiple files for a given query.\n\n        Args:\n            query: The query string to analyze against the files.\n            file_nodes: A list of FileNode instances representing the files to check.\n            context: The execution context for the LLM.\n\n        Returns:\n            A list of FileRelevancyResult containing relevancy information for each file.\n        \"\"\"\n        args_list = [(query, file_node.path, context) for file_node in file_nodes]\n        return self.async_execution.run_async_tasks_in_executor(self._determine_relevancy_for_single_file, *args_list)\n\n# Global variables/constants (if any)\n_SYSTEM_PROMPT_FILE_RELEVANCY: str = \"\"\"\nYou are a code analyzer that determines the relevancy of a file based on a given query.\n\nYour task is to analyze the file content and decide if it is relevant to the query. Provide a relevance score between 0 and 1, and an explanation for your decision.\n\n1 - The file is totally irrelevant to the query and it is exactly what the query asks for.\n1..0.8 - The file is relevant to the query, but it is not exactly what the query asks for.\n0.8..0.5 - The file may be relevant to the query.\n0.5..0.3 - The file is probably not relevant to the query.\n0.3..0 - The file is not relevant to the query.\n\nRules:\n1. Consider the context of the query and the file content.\n2. Evaluate if the file contains elements related to the query.\n3. Provide a boolean indicating relevancy (true/false).\n4. Assign a relevance score (0 to 1) based on the strength of the match.\n5. Offer a clear explanation for your decision.\n\nFormat your response as follows:\n\n<answer>\n<reasoning>Reasoning why the file is relevant or not relevant to the query.</reasoning>\n<score>0.85</score>\n<is_relevant>true</is_relevant>\n</answer>\n\nRemember:\n- Be concise and clear in your explanation.\n- Use the relevance score to reflect the degree of match.\n- Ensure the response is well-structured and follows the format.\n\"\"\"\n",
          "description": "\nThis file contains the implementation of a processor that determines the relevancy of files based on a given query using a language model (LLM). It includes a data model for the relevancy results and a method to analyze multiple files asynchronously. The public interface consists of the `FileRelevancyResult` data model and the `FileRelevancyLLMProcessor` class with its constructor and the `determine_relevancy` method.\n",
          "file_size": 4516,
          "file_hash": "64eddc1cfc06cc361ec8079229d1f4f4896bbdc1d380e47c910d278270aa92ec",
          "full_path": "/Users/martinsumera/projects/ai/kmp_coder/vanilla/code_search/llm/llm_file_relevancy.py",
          "extension": "py"
        },
        {
          "name": "llm_directory_description.py",
          "path": "/Users/martinsumera/projects/ai/kmp_coder/vanilla/code_search/llm/llm_directory_description.py",
          "last_modified": "2024-12-04T10:34:37.641666",
          "should_be_recalculated": false,
          "public_interface": "\n# Keep all imports\nfrom typing import List\nfrom pydantic import BaseModel\nfrom vanilla.code_search.file_system_nodes import DirectoryNode\nfrom vanilla.llm_executor import LLMExecutor\nfrom vanilla.execution_context import ExecutionContext\nfrom vanilla.llm import LLM_MODEL\nfrom vanilla.llm_tag import LLMTag\n\nclass DirectoryDescriptionResult(BaseModel):\n    \"\"\"\n    Represents the result of a directory description extraction.\n\n    Attributes:\n        description: A string containing the description of the directory.\n    \"\"\"\n    description: str\n\nclass DirectoryDescriptionLLMProcessor:\n    \"\"\"\n    Processor for extracting directory descriptions using a language model.\n\n    Attributes:\n        llm_executor: An instance of LLMExecutor used to generate descriptions.\n    \"\"\"\n    \n    def __init__(self, llm_executor: LLMExecutor) -> None:\n        \"\"\"\n        Initializes the DirectoryDescriptionLLMProcessor with an LLMExecutor.\n\n        Args:\n            llm_executor: An instance of LLMExecutor for generating descriptions.\n        \"\"\"\n        self.llm_executor = llm_executor\n\n    def extract_directory_description(self, directory_node: DirectoryNode) -> DirectoryDescriptionResult:\n        \"\"\"\n        Extract directory description including descriptions of all direct children (files and subdirectories).\n        \n        Raises:\n            ValueError: If any child description is missing.\n\n        Args:\n            directory_node: The DirectoryNode representing the directory to analyze.\n\n        Returns:\n            DirectoryDescriptionResult: The result containing the directory description.\n        \"\"\"\n        pass  # Implementation details omitted\n\n# Global variables/constants (if any)\n_SYSTEM_PROMPT: str = \"\"\"\nYou are a directory analyzer that creates comprehensive directory descriptions. You have background in software engineering and are able to understand the purpose of the code in the directory.\n\nYour task is to analyze a directory structure and create a clear description that explains:\n1. The overall purpose of the directory\n2. How the contents work together\n3. Any important patterns or conventions\n\nYour description will be used to help LLM agents understand the purpose of the directory and its contents. So make it descriptive and helpful.\n\nFormat your response as follows:\n\n<answer>\n<reasoning>\nA detailed explanation of your thought process for creating the description.\n</reasoning>\n<description>\nA clear, concise description of the directory that explains its purpose, contents, and how they work together.\nThe description should help developers understand what they can find in this directory and how it's organized.\n</description>\n</answer>\n\nRemember:\n- Focus on the directory's role in the larger system\n- Explain relationships between contained files/subdirectories\n- Highlight important patterns or conventions\n- Keep descriptions clear and concise\n\"\"\"\n",
          "description": "\nA clear, concise description of the directory that explains its purpose, contents, and how they work together.\nThe description should help developers understand what they can find in this directory and how it's organized.\n",
          "file_size": 4244,
          "file_hash": "6485edef1d803f05f6134ecba560d4acc5e12301a72160fe199ce978d1d22ba1",
          "full_path": "/Users/martinsumera/projects/ai/kmp_coder/vanilla/code_search/llm/llm_directory_description.py",
          "extension": "py"
        },
        {
          "name": "llm_file_description.py",
          "path": "/Users/martinsumera/projects/ai/kmp_coder/vanilla/code_search/llm/llm_file_description.py",
          "last_modified": "2024-12-04T14:46:09.864473",
          "should_be_recalculated": false,
          "public_interface": "\n# Keep all imports\nimport inspect\nfrom pydantic import BaseModel\nfrom vanilla.llm_executor import LLMExecutor\nfrom vanilla.execution_context import ExecutionContext\nfrom vanilla.llm import LLM_MODEL\nimport re\nfrom vanilla.llm_tag import LLMTag\n\nclass FileDescriptionResult(BaseModel):\n    \"\"\"\n    Represents the result of extracting a public interface and its description.\n    \n    Attributes:\n        public_interface: A string representation of the public interface.\n        description: A string description of the file.\n    \"\"\"\n    public_interface: str\n    description: str\n\nclass FileDescriptionLLMProcessor:\n    \"\"\"\n    Processor for extracting public interface information from code files using LLM.\n    \n    Attributes:\n        llm_executor: An instance of LLMExecutor used for generating responses.\n    \"\"\"\n\n    def __init__(self, llm_executor: LLMExecutor) -> None:\n        \"\"\"\n        Initializes the FileDescriptionLLMProcessor with an LLMExecutor.\n        \n        Args:\n            llm_executor: An instance of LLMExecutor to be used for LLM operations.\n        \"\"\"\n        self.llm_executor = llm_executor\n\n    def extract_public_interface_and_description(self, file_content: str, file_path: str) -> FileDescriptionResult:\n        \"\"\"\n        Extract public interface information from file content using LLM.\n        \n        Args:\n            file_content: The content of the file to analyze.\n            file_path: The path of the file being analyzed.\n            \n        Returns:\n            A FileDescriptionResult containing the public interface and description.\n        \"\"\"\n        pass  # Implementation details omitted\n",
          "description": "\nThis file contains classes and methods for extracting the public interface and description from code files using a language model. The `FileDescriptionResult` class is a data model for holding the results, while the `FileDescriptionLLMProcessor` class provides functionality to analyze code and return the public interface and description.\n",
          "file_size": 4147,
          "file_hash": "db5f6e2f537df05102152191456d43e4aead9851ace57e91aa3632aab6b227d5",
          "full_path": "/Users/martinsumera/projects/ai/kmp_coder/vanilla/code_search/llm/llm_file_description.py",
          "extension": "py"
        },
        {
          "name": "__init__.py",
          "path": "/Users/martinsumera/projects/ai/kmp_coder/vanilla/code_search/llm/__init__.py",
          "last_modified": "2024-12-03T14:55:51.072857",
          "should_be_recalculated": false,
          "public_interface": "\n# Keep all imports\nfrom typing import List, Optional\n\nclass CodeSearcher:\n    \"\"\"\n    A class to perform code searching operations.\n    \n    Attributes:\n        search_path (str): The path where the search will be conducted.\n    \"\"\"\n    \n    def __init__(self, search_path: str):\n        \"\"\"\n        Initializes the CodeSearcher with a specific search path.\n        \n        Args:\n            search_path: The directory path to search for code.\n        \"\"\"\n        pass  # Implementation details omitted\n\n    def search(self, query: str) -> List[str]:\n        \"\"\"\n        Searches for the given query in the specified search path.\n        \n        Args:\n            query: The search term to look for in the code files.\n            \n        Returns:\n            A list of file paths where the query was found.\n        \"\"\"\n        pass  # Implementation details omitted\n\n    def get_results(self) -> List[str]:\n        \"\"\"\n        Retrieves the results of the last search.\n        \n        Returns:\n            A list of results from the last search operation.\n        \"\"\"\n        pass  # Implementation details omitted\n\n# Global variables/constants (if any)\nDEFAULT_SEARCH_PATH: str = \"/usr/local/src\"  # Default path for searching code\n",
          "description": "\nThis file contains the implementation of a code searching utility. It provides a class `CodeSearcher` that allows users to search for specific queries within a designated directory. The public interface includes methods for initializing the searcher, performing searches, and retrieving results. Additionally, a default search path constant is defined for convenience.\n",
          "file_size": 0,
          "file_hash": "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
          "full_path": "/Users/martinsumera/projects/ai/kmp_coder/vanilla/code_search/llm/__init__.py",
          "extension": "py"
        }
      ],
      "directories": []
    }
  ],
  "_type": "DirectoryNode"
}