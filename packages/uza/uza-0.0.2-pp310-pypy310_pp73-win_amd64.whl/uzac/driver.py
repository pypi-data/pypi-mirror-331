from enum import Enum, auto
from pprint import pprint
import sys
from uzac.ast import Program
from uzac.bytecode import ByteCodeProgram, ByteCodeProgramSerializer
from uzac.interpreter import Interpreter
from uzac.parser import Parser
from uzac.typer import Typer, TyperDiagnostic
from uzac.utils import ANSIColor, UzaException, in_color
from vm.main import run_vm, run_vm_code


class Driver:
    class Configuration(Enum):
        PARSE = auto()
        TYPECHECK = auto()
        INTERPRET = auto()
        INTERPRET_BYTECODE = auto()
        COMPILE = auto()

    @staticmethod
    def run_with_config(
        config: Configuration,
        source: str = "",
        byte_code: bytes | None = None,
        output_file: str | None = None,
        verbose=False,
        omit_typechecking=False,
        err=sys.stderr,
    ) -> int:
        try:
            if byte_code != None:
                return run_vm_code(byte_code)

            prog = Driver.__parse(source=source, verbose=verbose, err=err)
            if config == Driver.Configuration.PARSE or prog.errors > 0:
                return prog.errors

            if not omit_typechecking:
                diag = Driver.__typecheck(prog, verbose=verbose, err=err)

            if config == Driver.Configuration.TYPECHECK or diag.error_count > 0:
                return diag.error_count

            if config == Driver.Configuration.INTERPRET:
                return Driver.__interpret(prog, verbose=verbose, err=err)

            byte_code_serializer = Driver.__compile(prog, verbose=verbose, err=err)
            if config == Driver.Configuration.COMPILE:
                try:
                    assert output_file
                    with open(output_file, "wb") as file:
                        wc = file.write(byte_code_serializer.get_bytes())
                        print(f"Wrote {wc} bytes to {output_file}", file=err)
                except OSError as e:
                    print(f"Error: {e.strerror}", file=err)
                    return 1
                return 0

            if config == Driver.Configuration.INTERPRET_BYTECODE:
                return Driver.__interpret_bytecode(byte_code_serializer)

        except UzaException as e:
            print(e.get_error_message(), file=err)

        return 1

    @staticmethod
    def __parse(source, verbose=False, err=sys.stderr) -> Program:
        program = Parser(source).parse()
        if verbose:
            print(in_color("\n### ast ###\n", ANSIColor.YELLOW), file=err)
            for _, node in enumerate(program.syntax_tree.lines):
                print(
                    node.span.start, end=": ", file=err
                )  # TODO: use line instead of codepoint
                pprint(node, stream=err, underscore_numbers=True, compact=False)

        if program.errors > 0:
            for node in program.failed_nodes:
                print(node.error_message, file=err)
        return program

    @staticmethod
    def __typecheck(program: Program, verbose=False, err=sys.stderr) -> TyperDiagnostic:
        typer_res: TyperDiagnostic = Typer(program).typecheck_program()
        if verbose:
            print(in_color("\n### inferred types ###", ANSIColor.YELLOW), file=err)

            print(typer_res.substitution.pretty_string(), file=err)
        if typer_res.warning_msg:
            print(typer_res.warning_msg, file=sys.stderr)
        for e in typer_res.errors:
            print(e.get_error_message(), file=err)

        return typer_res

    @staticmethod
    def __interpret(program: Program, verbose=False, err=sys.stderr) -> int:
        out = Interpreter(program).evaluate()
        if out and isinstance(out, int):
            return out
        return 0

    @staticmethod
    def __compile(
        program: Program, verbose=False, err=sys.stderr
    ) -> ByteCodeProgramSerializer:
        serializer = ByteCodeProgramSerializer(ByteCodeProgram(program))
        if verbose:
            print(in_color("### generated constants ###)", ANSIColor.YELLOW), file=err)
            for chunk in serializer.program.chunks:
                for constant in chunk.constants:
                    pprint(constant, stream=err)
            print(in_color("### generated bytecode ###)", ANSIColor.YELLOW), file=err)
            for chunk in serializer.program.chunks:
                print(f"Chunk: {chunk.name}", file=sys.stderr)
                pprint(chunk.code, stream=err)

        return serializer

    @staticmethod
    def __interpret_bytecode(program: ByteCodeProgramSerializer) -> int:
        return run_vm(program)
