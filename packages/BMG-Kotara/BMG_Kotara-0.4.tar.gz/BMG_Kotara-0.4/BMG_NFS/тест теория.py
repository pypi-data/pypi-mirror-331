# принцип прогоромирования tdd - test driven deveinpment
# даннный принцип придпологает что сначала создаються тесты для нужной функции которые будут проверять все возможные варианты ввода и вывода и только потом пишеться сама функция
# при каждом обновлении кода функции необходимо запустить и удостовериться что все они пройдены и нет никаких ошибок

# тесты всегда должны писаться данным образом - все входные данные и ожидыные результаты работы функции должны быть написаны "от руки " -  они не должны вычислятся самим тестом

def максимальное_число(список):
    if type(список) != list and type(список) !=tuple:
        raise TabError(F"Эта функция может принять список или кортеж. По факту был передан {type(список)}")
    # список = [5, 9, 2, 3, 15]
    наибольшее = список[0]
    for элимент in список:
        if элимент > наибольшее:
            наибольшее = элимент
    return наибольшее

def тест():
    название_теста = "список чисел"
    данные = [5, 9, 2, 3, 15, -30, 21, 0, 1, -50]
    ожидаймый_ответ = 21
    результат = максимальное_число(данные)
    if результат == ожидаймый_ответ:
        print(F'Тест"{название_теста}" пройден')
    else:
        print(f'тест "{название_теста}" не найден')
        print(f"ожидаймый ответ    - {ожидаймый_ответ}")
        print(f"получить результат - {результат}")


    название_теста = "передан не список"
    данные = "какойто текст"
    ожидаймый_ответ = "ошибка"
    try:
        результат = максимальное_число(данные)
    except:
        результат = " ошибка"
    if результат == ожидаймый_ответ:
        print(F'Тест"{название_теста}" пройден')
    else:
        print(f'тест "{название_теста}" не найден')
        print(f"ожидаймый ответ    - {ожидаймый_ответ}")
        print(f"получить результат - {результат}")

        # создать тест который выдадет ошибку "внутри списка могут быть только целые или дробное число"
        # дробное число - тип flant
        # целое число - тип int
        # данныу - [слово 5 10 15 5]

тест()