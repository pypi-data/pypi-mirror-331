# This file was auto-generated by Fern from our API Definition.

import typing
from ..core.client_wrapper import SyncClientWrapper
from ..core.request_options import RequestOptions
from ..types.assistant import Assistant
from ..core.pydantic_utilities import parse_obj_as
from ..errors.unprocessable_entity_error import UnprocessableEntityError
from ..types.http_validation_error import HttpValidationError
from json.decoder import JSONDecodeError
from ..core.api_error import ApiError
from ..types.if_exists import IfExists
from ..core.jsonable_encoder import jsonable_encoder
from ..types.assistant_version import AssistantVersion
from ..core.client_wrapper import AsyncClientWrapper

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class AssistantsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def list_assistants(
        self, *, include_public: typing.Optional[bool] = None, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.List[Assistant]:
        """
        List assistants for the current user.

        Parameters
        ----------
        include_public : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Assistant]
            Successful Response

        Examples
        --------
        from akili import AkiliApi

        client = AkiliApi(
            token="YOUR_TOKEN",
        )
        client.assistants.list_assistants()
        """
        _response = self._client_wrapper.httpx_client.request(
            "assistants",
            method="GET",
            params={
                "include_public": include_public,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[Assistant],
                    parse_obj_as(
                        type_=typing.List[Assistant],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_assistant(
        self,
        *,
        name: str,
        config: typing.Dict[str, typing.Optional[typing.Any]],
        graph_id: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        public: typing.Optional[bool] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        if_exists: typing.Optional[IfExists] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Assistant:
        """
        Create an assistant.

        Parameters
        ----------
        name : str
            The name of the assistant.

        config : typing.Dict[str, typing.Optional[typing.Any]]
            The assistant config.

        graph_id : typing.Optional[str]
            The ID of the graph.

        description : typing.Optional[str]
            The description of the assistant. This will be stored in metadata.annotations.description.

        public : typing.Optional[bool]
            Whether the assistant is public.

        metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            The metadata of the assistant, including annotations.

        if_exists : typing.Optional[IfExists]
            How to handle duplicate creation. Must be either 'raise' (raise error if duplicate), or 'do_nothing' (return existing assistant).

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Assistant
            Successful Response

        Examples
        --------
        from akili import AkiliApi

        client = AkiliApi(
            token="YOUR_TOKEN",
        )
        client.assistants.create_assistant(
            name="name",
            config={"key": "value"},
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "assistants",
            method="POST",
            json={
                "graph_id": graph_id,
                "name": name,
                "description": description,
                "config": config,
                "public": public,
                "metadata": metadata,
                "if_exists": if_exists,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Assistant,
                    parse_obj_as(
                        type_=Assistant,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_assistant(self, aid: str, *, request_options: typing.Optional[RequestOptions] = None) -> Assistant:
        """
        Get an assistant by ID.

        Parameters
        ----------
        aid : str
            The ID of the assistant.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Assistant
            Successful Response

        Examples
        --------
        from akili import AkiliApi

        client = AkiliApi(
            token="YOUR_TOKEN",
        )
        client.assistants.get_assistant(
            aid="aid",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"assistants/{jsonable_encoder(aid)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Assistant,
                    parse_obj_as(
                        type_=Assistant,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def upsert_assistant(
        self,
        aid: str,
        *,
        name: str,
        config: typing.Dict[str, typing.Optional[typing.Any]],
        graph_id: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        public: typing.Optional[bool] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        if_exists: typing.Optional[IfExists] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Assistant:
        """
        Create or update an assistant.

        Parameters
        ----------
        aid : str
            The ID of the assistant.

        name : str
            The name of the assistant.

        config : typing.Dict[str, typing.Optional[typing.Any]]
            The assistant config.

        graph_id : typing.Optional[str]
            The ID of the graph.

        description : typing.Optional[str]
            The description of the assistant. This will be stored in metadata.annotations.description.

        public : typing.Optional[bool]
            Whether the assistant is public.

        metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            The metadata of the assistant, including annotations.

        if_exists : typing.Optional[IfExists]
            How to handle duplicate creation. Must be either 'raise' (raise error if duplicate), or 'do_nothing' (return existing assistant).

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Assistant
            Successful Response

        Examples
        --------
        from akili import AkiliApi

        client = AkiliApi(
            token="YOUR_TOKEN",
        )
        client.assistants.upsert_assistant(
            aid="aid",
            name="name",
            config={"key": "value"},
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"assistants/{jsonable_encoder(aid)}",
            method="PUT",
            json={
                "graph_id": graph_id,
                "name": name,
                "description": description,
                "config": config,
                "public": public,
                "metadata": metadata,
                "if_exists": if_exists,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Assistant,
                    parse_obj_as(
                        type_=Assistant,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete_assistant(
        self, aid: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.Optional[typing.Any]:
        """
        Delete an assistant by ID.

        All versions of the assistant will be deleted as well.

        Parameters
        ----------
        aid : str
            The ID of the assistant.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Optional[typing.Any]
            Successful Response

        Examples
        --------
        from akili import AkiliApi

        client = AkiliApi(
            token="YOUR_TOKEN",
        )
        client.assistants.delete_assistant(
            aid="aid",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"assistants/{jsonable_encoder(aid)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.Optional[typing.Any],
                    parse_obj_as(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def patch_assistant(
        self,
        aid: str,
        *,
        graph_id: typing.Optional[str] = OMIT,
        name: typing.Optional[str] = OMIT,
        config: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Assistant:
        """
        Update an assistant with partial updates.

        This endpoint allows updating specific fields of an assistant without
        requiring all fields to be provided. Only the fields that are provided
        will be updated.

        Parameters
        ----------
        aid : str
            The ID of the assistant.

        graph_id : typing.Optional[str]
            The ID of the graph the assistant should use.

        name : typing.Optional[str]
            The new name for the assistant.

        config : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Configuration to use for the graph.

        metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Metadata to merge with existing assistant metadata.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Assistant
            Successful Response

        Examples
        --------
        from akili import AkiliApi

        client = AkiliApi(
            token="YOUR_TOKEN",
        )
        client.assistants.patch_assistant(
            aid="aid",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"assistants/{jsonable_encoder(aid)}",
            method="PATCH",
            json={
                "graph_id": graph_id,
                "name": name,
                "config": config,
                "metadata": metadata,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Assistant,
                    parse_obj_as(
                        type_=Assistant,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_assistant_graph(
        self, aid: str, *, xray: typing.Optional[int] = None, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.Optional[typing.Any]:
        """
        Get Assistant Graph​

        Parameters
        ----------
        aid : str
            The ID of the assistant.

        xray : typing.Optional[int]
            Include graph representation of subgraphs. If an integer value is provided, only subgraphs with a depth less than or equal to the value will be included.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Optional[typing.Any]
            Successful Response

        Examples
        --------
        from akili import AkiliApi

        client = AkiliApi(
            token="YOUR_TOKEN",
        )
        client.assistants.get_assistant_graph(
            aid="aid",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"assistants/{jsonable_encoder(aid)}/graph",
            method="GET",
            params={
                "xray": xray,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.Optional[typing.Any],
                    parse_obj_as(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_assistant_subgraph(
        self,
        aid: str,
        *,
        recurse: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Optional[typing.Any]:
        """
        Get an assistant's subgraphs.

        Parameters
        ----------
        aid : str
            The ID of the assistant.

        recurse : typing.Optional[bool]
            Recursively retrieve subgraphs of subgraphs.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Optional[typing.Any]
            Successful Response

        Examples
        --------
        from akili import AkiliApi

        client = AkiliApi(
            token="YOUR_TOKEN",
        )
        client.assistants.get_assistant_subgraph(
            aid="aid",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"assistants/{jsonable_encoder(aid)}/subgraphs",
            method="GET",
            params={
                "recurse": recurse,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.Optional[typing.Any],
                    parse_obj_as(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_assistant_subgraph_by_namespace(
        self,
        aid: str,
        namespace: str,
        *,
        recurse: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Optional[typing.Any]:
        """
        Get an assistant's subgraphs filtered by namespace.

        Parameters
        ----------
        aid : str
            The ID of the assistant.

        namespace : str
            Namespace of the subgraph to filter by.

        recurse : typing.Optional[bool]
            Recursively retrieve subgraphs of subgraphs.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Optional[typing.Any]
            Successful Response

        Examples
        --------
        from akili import AkiliApi

        client = AkiliApi(
            token="YOUR_TOKEN",
        )
        client.assistants.get_assistant_subgraph_by_namespace(
            aid="aid",
            namespace="namespace",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"assistants/{jsonable_encoder(aid)}/subgraphs/{jsonable_encoder(namespace)}",
            method="GET",
            params={
                "recurse": recurse,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.Optional[typing.Any],
                    parse_obj_as(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_assistant_schemas(
        self, aid: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.Optional[typing.Any]:
        """
        Get Assistant Schemas

        Parameters
        ----------
        aid : str
            The ID of the assistant.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Optional[typing.Any]
            Successful Response

        Examples
        --------
        from akili import AkiliApi

        client = AkiliApi(
            token="YOUR_TOKEN",
        )
        client.assistants.get_assistant_schemas(
            aid="aid",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"assistants/{jsonable_encoder(aid)}/schemas",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.Optional[typing.Any],
                    parse_obj_as(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_assistant_versions(
        self, aid: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.List[AssistantVersion]:
        """
        Get all versions of an assistant.

        This endpoint returns all versions of an assistant. The user must be the owner of the assistant
        or the assistant must be public.

        Parameters
        ----------
        aid : str
            The ID of the assistant.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[AssistantVersion]
            Successful Response

        Examples
        --------
        from akili import AkiliApi

        client = AkiliApi(
            token="YOUR_TOKEN",
        )
        client.assistants.get_assistant_versions(
            aid="aid",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"assistants/{jsonable_encoder(aid)}/versions",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[AssistantVersion],
                    parse_obj_as(
                        type_=typing.List[AssistantVersion],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def set_latest_version(
        self, aid: str, *, version: int, request_options: typing.Optional[RequestOptions] = None
    ) -> Assistant:
        """
        Set the latest version of an assistant.

        Parameters
        ----------
        aid : str
            The ID of the assistant.

        version : int

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Assistant
            Successful Response

        Examples
        --------
        from akili import AkiliApi

        client = AkiliApi(
            token="YOUR_TOKEN",
        )
        client.assistants.set_latest_version(
            aid="aid",
            version=1,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"assistants/{jsonable_encoder(aid)}/latest",
            method="POST",
            params={
                "version": version,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Assistant,
                    parse_obj_as(
                        type_=Assistant,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def search_assistants(
        self,
        *,
        metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        graph_id: typing.Optional[str] = OMIT,
        limit: typing.Optional[int] = OMIT,
        offset: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[Assistant]:
        """
        Search for assistants.

        This endpoint allows filtering assistants by metadata and graph_id,
        with pagination support through limit and offset parameters.

        Parameters
        ----------
        metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Metadata to filter by. Exact match filter for each KV pair.

        graph_id : typing.Optional[str]
            The ID of the graph to filter by.

        limit : typing.Optional[int]
            The maximum number of results to return.

        offset : typing.Optional[int]
            The number of results to skip.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Assistant]
            Successful Response

        Examples
        --------
        from akili import AkiliApi

        client = AkiliApi(
            token="YOUR_TOKEN",
        )
        client.assistants.search_assistants()
        """
        _response = self._client_wrapper.httpx_client.request(
            "assistants/search",
            method="POST",
            json={
                "metadata": metadata,
                "graph_id": graph_id,
                "limit": limit,
                "offset": offset,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[Assistant],
                    parse_obj_as(
                        type_=typing.List[Assistant],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncAssistantsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def list_assistants(
        self, *, include_public: typing.Optional[bool] = None, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.List[Assistant]:
        """
        List assistants for the current user.

        Parameters
        ----------
        include_public : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Assistant]
            Successful Response

        Examples
        --------
        import asyncio

        from akili import AsyncAkiliApi

        client = AsyncAkiliApi(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.assistants.list_assistants()


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "assistants",
            method="GET",
            params={
                "include_public": include_public,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[Assistant],
                    parse_obj_as(
                        type_=typing.List[Assistant],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_assistant(
        self,
        *,
        name: str,
        config: typing.Dict[str, typing.Optional[typing.Any]],
        graph_id: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        public: typing.Optional[bool] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        if_exists: typing.Optional[IfExists] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Assistant:
        """
        Create an assistant.

        Parameters
        ----------
        name : str
            The name of the assistant.

        config : typing.Dict[str, typing.Optional[typing.Any]]
            The assistant config.

        graph_id : typing.Optional[str]
            The ID of the graph.

        description : typing.Optional[str]
            The description of the assistant. This will be stored in metadata.annotations.description.

        public : typing.Optional[bool]
            Whether the assistant is public.

        metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            The metadata of the assistant, including annotations.

        if_exists : typing.Optional[IfExists]
            How to handle duplicate creation. Must be either 'raise' (raise error if duplicate), or 'do_nothing' (return existing assistant).

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Assistant
            Successful Response

        Examples
        --------
        import asyncio

        from akili import AsyncAkiliApi

        client = AsyncAkiliApi(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.assistants.create_assistant(
                name="name",
                config={"key": "value"},
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "assistants",
            method="POST",
            json={
                "graph_id": graph_id,
                "name": name,
                "description": description,
                "config": config,
                "public": public,
                "metadata": metadata,
                "if_exists": if_exists,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Assistant,
                    parse_obj_as(
                        type_=Assistant,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_assistant(self, aid: str, *, request_options: typing.Optional[RequestOptions] = None) -> Assistant:
        """
        Get an assistant by ID.

        Parameters
        ----------
        aid : str
            The ID of the assistant.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Assistant
            Successful Response

        Examples
        --------
        import asyncio

        from akili import AsyncAkiliApi

        client = AsyncAkiliApi(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.assistants.get_assistant(
                aid="aid",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"assistants/{jsonable_encoder(aid)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Assistant,
                    parse_obj_as(
                        type_=Assistant,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def upsert_assistant(
        self,
        aid: str,
        *,
        name: str,
        config: typing.Dict[str, typing.Optional[typing.Any]],
        graph_id: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        public: typing.Optional[bool] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        if_exists: typing.Optional[IfExists] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Assistant:
        """
        Create or update an assistant.

        Parameters
        ----------
        aid : str
            The ID of the assistant.

        name : str
            The name of the assistant.

        config : typing.Dict[str, typing.Optional[typing.Any]]
            The assistant config.

        graph_id : typing.Optional[str]
            The ID of the graph.

        description : typing.Optional[str]
            The description of the assistant. This will be stored in metadata.annotations.description.

        public : typing.Optional[bool]
            Whether the assistant is public.

        metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            The metadata of the assistant, including annotations.

        if_exists : typing.Optional[IfExists]
            How to handle duplicate creation. Must be either 'raise' (raise error if duplicate), or 'do_nothing' (return existing assistant).

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Assistant
            Successful Response

        Examples
        --------
        import asyncio

        from akili import AsyncAkiliApi

        client = AsyncAkiliApi(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.assistants.upsert_assistant(
                aid="aid",
                name="name",
                config={"key": "value"},
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"assistants/{jsonable_encoder(aid)}",
            method="PUT",
            json={
                "graph_id": graph_id,
                "name": name,
                "description": description,
                "config": config,
                "public": public,
                "metadata": metadata,
                "if_exists": if_exists,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Assistant,
                    parse_obj_as(
                        type_=Assistant,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete_assistant(
        self, aid: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.Optional[typing.Any]:
        """
        Delete an assistant by ID.

        All versions of the assistant will be deleted as well.

        Parameters
        ----------
        aid : str
            The ID of the assistant.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Optional[typing.Any]
            Successful Response

        Examples
        --------
        import asyncio

        from akili import AsyncAkiliApi

        client = AsyncAkiliApi(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.assistants.delete_assistant(
                aid="aid",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"assistants/{jsonable_encoder(aid)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.Optional[typing.Any],
                    parse_obj_as(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def patch_assistant(
        self,
        aid: str,
        *,
        graph_id: typing.Optional[str] = OMIT,
        name: typing.Optional[str] = OMIT,
        config: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Assistant:
        """
        Update an assistant with partial updates.

        This endpoint allows updating specific fields of an assistant without
        requiring all fields to be provided. Only the fields that are provided
        will be updated.

        Parameters
        ----------
        aid : str
            The ID of the assistant.

        graph_id : typing.Optional[str]
            The ID of the graph the assistant should use.

        name : typing.Optional[str]
            The new name for the assistant.

        config : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Configuration to use for the graph.

        metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Metadata to merge with existing assistant metadata.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Assistant
            Successful Response

        Examples
        --------
        import asyncio

        from akili import AsyncAkiliApi

        client = AsyncAkiliApi(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.assistants.patch_assistant(
                aid="aid",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"assistants/{jsonable_encoder(aid)}",
            method="PATCH",
            json={
                "graph_id": graph_id,
                "name": name,
                "config": config,
                "metadata": metadata,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Assistant,
                    parse_obj_as(
                        type_=Assistant,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_assistant_graph(
        self, aid: str, *, xray: typing.Optional[int] = None, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.Optional[typing.Any]:
        """
        Get Assistant Graph​

        Parameters
        ----------
        aid : str
            The ID of the assistant.

        xray : typing.Optional[int]
            Include graph representation of subgraphs. If an integer value is provided, only subgraphs with a depth less than or equal to the value will be included.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Optional[typing.Any]
            Successful Response

        Examples
        --------
        import asyncio

        from akili import AsyncAkiliApi

        client = AsyncAkiliApi(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.assistants.get_assistant_graph(
                aid="aid",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"assistants/{jsonable_encoder(aid)}/graph",
            method="GET",
            params={
                "xray": xray,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.Optional[typing.Any],
                    parse_obj_as(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_assistant_subgraph(
        self,
        aid: str,
        *,
        recurse: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Optional[typing.Any]:
        """
        Get an assistant's subgraphs.

        Parameters
        ----------
        aid : str
            The ID of the assistant.

        recurse : typing.Optional[bool]
            Recursively retrieve subgraphs of subgraphs.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Optional[typing.Any]
            Successful Response

        Examples
        --------
        import asyncio

        from akili import AsyncAkiliApi

        client = AsyncAkiliApi(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.assistants.get_assistant_subgraph(
                aid="aid",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"assistants/{jsonable_encoder(aid)}/subgraphs",
            method="GET",
            params={
                "recurse": recurse,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.Optional[typing.Any],
                    parse_obj_as(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_assistant_subgraph_by_namespace(
        self,
        aid: str,
        namespace: str,
        *,
        recurse: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Optional[typing.Any]:
        """
        Get an assistant's subgraphs filtered by namespace.

        Parameters
        ----------
        aid : str
            The ID of the assistant.

        namespace : str
            Namespace of the subgraph to filter by.

        recurse : typing.Optional[bool]
            Recursively retrieve subgraphs of subgraphs.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Optional[typing.Any]
            Successful Response

        Examples
        --------
        import asyncio

        from akili import AsyncAkiliApi

        client = AsyncAkiliApi(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.assistants.get_assistant_subgraph_by_namespace(
                aid="aid",
                namespace="namespace",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"assistants/{jsonable_encoder(aid)}/subgraphs/{jsonable_encoder(namespace)}",
            method="GET",
            params={
                "recurse": recurse,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.Optional[typing.Any],
                    parse_obj_as(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_assistant_schemas(
        self, aid: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.Optional[typing.Any]:
        """
        Get Assistant Schemas

        Parameters
        ----------
        aid : str
            The ID of the assistant.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Optional[typing.Any]
            Successful Response

        Examples
        --------
        import asyncio

        from akili import AsyncAkiliApi

        client = AsyncAkiliApi(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.assistants.get_assistant_schemas(
                aid="aid",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"assistants/{jsonable_encoder(aid)}/schemas",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.Optional[typing.Any],
                    parse_obj_as(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_assistant_versions(
        self, aid: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.List[AssistantVersion]:
        """
        Get all versions of an assistant.

        This endpoint returns all versions of an assistant. The user must be the owner of the assistant
        or the assistant must be public.

        Parameters
        ----------
        aid : str
            The ID of the assistant.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[AssistantVersion]
            Successful Response

        Examples
        --------
        import asyncio

        from akili import AsyncAkiliApi

        client = AsyncAkiliApi(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.assistants.get_assistant_versions(
                aid="aid",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"assistants/{jsonable_encoder(aid)}/versions",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[AssistantVersion],
                    parse_obj_as(
                        type_=typing.List[AssistantVersion],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def set_latest_version(
        self, aid: str, *, version: int, request_options: typing.Optional[RequestOptions] = None
    ) -> Assistant:
        """
        Set the latest version of an assistant.

        Parameters
        ----------
        aid : str
            The ID of the assistant.

        version : int

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Assistant
            Successful Response

        Examples
        --------
        import asyncio

        from akili import AsyncAkiliApi

        client = AsyncAkiliApi(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.assistants.set_latest_version(
                aid="aid",
                version=1,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"assistants/{jsonable_encoder(aid)}/latest",
            method="POST",
            params={
                "version": version,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Assistant,
                    parse_obj_as(
                        type_=Assistant,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def search_assistants(
        self,
        *,
        metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        graph_id: typing.Optional[str] = OMIT,
        limit: typing.Optional[int] = OMIT,
        offset: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[Assistant]:
        """
        Search for assistants.

        This endpoint allows filtering assistants by metadata and graph_id,
        with pagination support through limit and offset parameters.

        Parameters
        ----------
        metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Metadata to filter by. Exact match filter for each KV pair.

        graph_id : typing.Optional[str]
            The ID of the graph to filter by.

        limit : typing.Optional[int]
            The maximum number of results to return.

        offset : typing.Optional[int]
            The number of results to skip.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Assistant]
            Successful Response

        Examples
        --------
        import asyncio

        from akili import AsyncAkiliApi

        client = AsyncAkiliApi(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.assistants.search_assistants()


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "assistants/search",
            method="POST",
            json={
                "metadata": metadata,
                "graph_id": graph_id,
                "limit": limit,
                "offset": offset,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[Assistant],
                    parse_obj_as(
                        type_=typing.List[Assistant],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
