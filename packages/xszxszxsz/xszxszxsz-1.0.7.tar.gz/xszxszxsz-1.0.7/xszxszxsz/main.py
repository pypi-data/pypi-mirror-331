
def one():
        print(
            'import cv2\nimport matplotlib.pyplot as plt\n%matplotlib inline\n\n# 读取图像，第二个参数为1表示读取彩色图像，为0表示图像灰度图像\nim = cv2.imread("./images/panda.png",1)\nim_gray = cv2.imread("./images/panda.png",0)\n#新建画布\nplt.figure()\n#用matplotlib图片显示彩色不正常\nplt.subplot(1,2,1),plt.imshow(im)\nplt.subplot(1,2,2),plt.imshow(im_gray,\'gray\')\nplt.show()\n#因为CV2读取图像的通道顺序为BGR，而Matplotlib显示图像的通道顺讯为RGB，因此需要调换颜色通道顺序\nim_RGB = cv2.cvtColor(im,cv2.COLOR_BGR2RGB)\nplt.subplot(1,2,1),plt.imshow(im_RGB)\nplt.subplot(1,2,2),plt.imshow(im_gray,\'gray\')\n#打印图像数据类型\nprint(im.dtype)\n# 打印图像大小\nprint(im.shape)\n# 保存图像到指定路径\ncv2.imwrite(\'./panda.png\',im)\nim = cv2.imread("./images/panda.png")\n\n# 使用cvtColor进行颜色空间变化 cv2.COLOR_BGR2GRAY 代表BGR to gray\n\nimg_gray = cv2.cvtColor(im, cv2.COLOR_BGR2GRAY)\n\n\nplt.imshow(im_gray,\'gray\')\nim = cv2.imread("./images/panda.png")\n\n# 使用cvtColor进行颜色空间变化 cv2.COLOR_BGR2HSV\n\nim_hsv= cv2.cvtColor(im, cv2.COLOR_BGR2HSV)\n\n# 当图像数据为3通道时，imshow函数认为数据是RGB的\n\n# 使用imshow显示HSV数据，会发现图片显示颜色畸变\n\nplt.imshow(im_hsv)\n')

def two():
    print('任务一 灰度变换\n请按照以下步骤，参照代码语句进行图像预处理的相关操作，可根据对代码的理解与实际需求对代码语句进行修改，代码仅作为参考。其中数据路径根据具体情况而定，这里只作为参考依据。\n步骤1 反转，灰度拉伸，灰度压缩\n下面具体讲解了反转、灰度拉伸、灰度压缩等灰度变换基本预处理操作，相关操作函数请具体看下面输入语句，脚本中有备注文本描述，有助于代码的更好理解。\n输入：\n\nimport numpy as np\nimport cv2\nfrom matplotlib import pyplot as plt\n%matplotlib inline\n​\n# 定义线性灰度变化函数\n# k>1时 实现灰度数值的拉伸\n# 0<k<1时 实现灰度数值的压缩\n# k=-1 b=255 实现灰度反转\ndef linear_trans(img, k, b=0):\n    # 计算灰度线性变化的映射表\n    trans_list = [(np.float32(x)*k+b) for x in range(256)]\n    # 将列表转换为np.array\n    trans_table =np.array(trans_list)\n    # 将超过[0,255]灰度范围的数值进行调整,并指定数据类型为uint8\n    trans_table[trans_table>255] = 255\n    trans_table[trans_table<0] = 0\n    trans_table = np.round(trans_table).astype(np.uint8)\n    # 使用OpenCV的look up table函数修改图像的灰度值\n    return cv2.LUT(img, trans_table)\n​\nim = cv2.imread(\'/data/CV-ascend/images/panda.png\',0)\nplt.figure(figsize=(8,8))\nplt.subplot(2,2,1),plt.title(\'original\'),plt.imshow(im,\'gray\')\n​\n# 反转\nim_inversion = linear_trans(im, -1, 255)\nplt.subplot(2,2,2),plt.title(\'reversed\'),plt.imshow(im_inversion,\'gray\')\n# 灰度拉伸\nim_stretch = linear_trans(im, 1.2)\nplt.subplot(2,2,3),plt.title(\'stretch\'),plt.imshow(im_stretch,\'gray\')\n# 灰度压缩\nim_compress = linear_trans(im, 0.4)\nplt.subplot(2,2,4),plt.title(\'compress\'),plt.imshow(im_compress,\'gray\')\n输出：\n\n(<matplotlib.axes._subplots.AxesSubplot at 0xfffed7ed5390>,\n Text(0.5, 1.0, \'compress\'),\n <matplotlib.image.AxesImage at 0xfffed7e8fd10>)\n\n步骤2 伽马变换\n输入：\n\ndef gamma_trans(img, gamma):\n    # 先归一化到1，做伽马计算，再还原到[0,255]\n    gamma_list = [np.power(x / 255.0, gamma) * 255.0 for x in range(256)]\n    # 将列表转换为np.array，并指定数据类型为uint8\n    gamma_table = np.round(np.array(gamma_list)).astype(np.uint8)\n    # 使用OpenCV的look up table函数修改图像的灰度值\n    return cv2.LUT(img, gamma_table)\n​\nim = cv2.imread(\'/data/CV-ascend/images/panda.png\',0)\nplt.figure(figsize=(8,8))\nplt.subplot(1,3,1),plt.title(\'original\'),plt.imshow(im,\'gray\')\n​\n# 使用伽马值为0.5的变化，实现对暗部的拉升，亮部的压缩\nim_gamma05 = gamma_trans(im, 0.5)\nplt.subplot(1,3,2),plt.title(\'gammar=0.5\'),plt.imshow(im_gamma05,\'gray\')\n# 使用伽马值为2的变化，实现对亮部的拉升，暗部的压缩\nim_gamma2 = gamma_trans(im, 2)\nplt.subplot(1,3,3),plt.title(\'gammart=2\'),plt.imshow(im_gamma2,\'gray\')\n输出：\n\n(<matplotlib.axes._subplots.AxesSubplot at 0xfffed7d5a550>,\n Text(0.5, 1.0, \'gammart=2\'),\n <matplotlib.image.AxesImage at 0xfffed7d92ed0>)\n\n任务二 直方图\n步骤1 直方图的显示\n输入：\n\nimport cv2\nfrom matplotlib import pyplot as plt\n# 读取并显示图像\nim = cv2.imread(\'/data/CV-ascend/images/panda.png\',0)\nplt.imshow(im,\'gray\')\n​\n# 绘制灰度图像的直方图\nplt.figure()\nplt.hist(im.ravel(), 256, [0,256])\nplt.show()\n输出：\n\n\n步骤2 直方图均衡化\n输入：\n\nimport cv2\nfrom matplotlib import pyplot as plt\n​\nim = cv2.imread(\'/data/CV-ascend/images/panda.png\',0)\nplt.figure(figsize=(8,8))\nplt.subplot(2,2,1),plt.imshow(im,\'gray\')\n​\n# 调用OpenCV的直方图均衡化API\nim_equa1 = cv2.equalizeHist(im)\nplt.subplot(2,2,3),plt.imshow(im_equa1,\'gray\')\n​\n# 显示原始图像的直方图\nplt.subplot(2,2,2)\nplt.hist(im.ravel(), 256, [0,256],label=\'org\')\nplt.legend()\n​\n# 显示均衡化图像的直方图\nplt.subplot(2,2,4)\nplt.hist(im_equa1.ravel(), 256, [0,256],label=\'equalize\')\nplt.legend()\nplt.show()\n输出：\n\n任务三 图像二值化\n一幅图像包括前景（目标）、背景还有噪声，要想从数字图像中直接提取出前景目标，常用的方法就是二值法。 设定一个阈值T，用T将图像的数据分成两部分：大于T的像素群和小于T的像素群。这是研究灰度变换的方法，称为图像的二值化（Binarization）。 \n步骤1 简单图像二值化 - 阈值\nPython-OpenCV中提供了阈值（threshold）函数：cv2.threshold（src,x,y,method）\nsrc：原图像，原图像应该是灰度图。\nx：用来对像素值进行分类的阈值。\ny：填充色。\nmethod：指选择二值的方法。 cv2.THRESH_BINARY（黑白二值）：此时小于阈值的像素点置0，大于阈值的像素点置填充色 cv2.THRESH_BINARY_INV（黑白二值反转)：此时小于阈值的像素点置填充色，大于阈值的像素点置0 cv2.THRESH_TRUNC（得到的图像为多像素值）：此时小于阈值的像素点保持原色，大于阈值的像素点置灰色 cv2.THRESH_TOZERO：此时小于阈值的像素点置0，大于阈值的像素点保持原色 cv2.THRESH_TOZERO_INV：此时小于阈值的像素点保持原色，大于阈值的像素点置0\n该函数有两个返回值，第一个retVal（得到的阈值值（在后面一个方法中会用到）），第二个就是阈值化后的图像。\n输入：\n\nimg = cv2.imread(\'/data/CV-ascend/images/panda.png\',0)\n​\n_,thresh1 = cv2.threshold(img,127,255,cv2.THRESH_BINARY)\n_,thresh2 = cv2.threshold(img,127,255,cv2.THRESH_BINARY_INV)\n_,thresh3 = cv2.threshold(img,127,255,cv2.THRESH_TRUNC)\n_,thresh4 = cv2.threshold(img,127,255,cv2.THRESH_TOZERO)\n_,thresh5 = cv2.threshold(img,127,255,cv2.THRESH_TOZERO_INV)\ntitles = [\'img\',\'BINARY\',\'BINARY_INV\',\'TRUNC\',\'TOZERO\',\'TOZERO_INV\']\nimagess = [img,thresh1,thresh2,thresh3,thresh4,thresh5]\n\nplt.figure(figsize=(8,8))\nfor i in range(6):\n    plt.subplot(2,3,i+1)\n    plt.imshow(imagess[i],\'gray\')\n    plt.title(titles[i])\nplt.show()\n输出：\n\n步骤2 自适应阈值\n自适应阈值用于解决图片中明暗不均导致阈值设置不能有效分割图像。 Python-OpenCV中提供了自适应函数cv2.adaptiveThreshold(src,pix,adaptiveMethod,thresholdType,blocksize,C):\nsrc：输入图像\npix：像素值上限\nadaptiveMethod：在一个邻域内计算阈值所采用的算法，有两个取值，分别为 ADAPTIVE_THRESH_MEAN_C 和 ADAPTIVE_THRESH_GAUSSIAN_C ADAPTIVE_THRESH_MEAN_C的计算方法是计算出领域的平均值再减去第六个参数double C的值 ADAPTIVE_THRESH_GAUSSIAN_C的计算方法是计算出领域的高斯均值再减去第六个参数double C的值\nthresholdType：这是阈值类型，只有两个取值，分别为 THRESH_BINARY 和THRESH_BINARY_INV\nblockSize：adaptiveThreshold的计算单位是像素的邻域块，这是局部邻域大小，3、5、7等\nC：这个参数实际上是一个偏移值调整量，用均值和高斯计算阈值后，再减或加这个值就是最终阈值\n输入：\n\nimg = cv2.imread(\'/data/CV-ascend/images/panda.png\',0) #读取灰度图像\n_,th1 = cv2.threshold(img,127,255,cv2.THRESH_BINARY)\nth2 = cv2.adaptiveThreshold(img,255,cv2.ADAPTIVE_THRESH_MEAN_C,cv2.THRESH_BINARY,11,2) \nth3 = cv2.adaptiveThreshold(img,255,cv2.ADAPTIVE_THRESH_GAUSSIAN_C,cv2.THRESH_BINARY,11,2)\nimagess = [img,th1,th2,th3]\nplt.figure(figsize=(8,8))\nfor i in range(4):\n    plt.subplot(2,2,i+1)\n    plt.imshow(imagess[i],\'gray\')\nplt.show()\n输出：\n\n任务四 大津阈值法（OSTU）\n实验比较了大津阈值法与一般手动阈值法，呈现的图像分割效果。大津阈值法可以自动选择阈值。\n输入：\n\nimg = cv2.imread(\'/data/CV-ascend/images/panda.png\',0) #直接读为灰度图像\n#简单分割阈值\nret1,th1 = cv2.threshold(img,127,255,cv2.THRESH_BINARY)\n#Otsu 滤波\nret2,th2 = cv2.threshold(img,0,255,cv2.THRESH_OTSU)\nprint(\'简单分割阈值:\',ret1)\nprint(\'最佳分割阈值:\',ret2)\nplt.figure(figsize=(8,8))\nplt.subplot(221),plt.imshow(img,\'gray\')\nplt.subplot(222),plt.hist(img.ravel(),256)#.ravel方法将矩阵转化为一维\nplt.subplot(223),plt.imshow(th1,\'gray\')\nplt.subplot(224),plt.imshow(th2,\'gray\')\n输出：\n\n简单分割阈值: 127.0\n最佳分割阈值: 117.0\n(<matplotlib.axes._subplots.AxesSubplot at 0xfffed5858690>,\n <matplotlib.image.AxesImage at 0xfffed553a210>)\n\n')
def three():
        print('任务一 坐标变换\n步骤1 平移\n输入：\n\nimport numpy as np\nimport cv2\nimport matplotlib.pyplot as plt\n%matplotlib inline\n​\n# 定义平移translate函数\ndef translate(img, x, y):\n    # 获取图像尺寸\n    (h, w) = img.shape[:2]\n    \n    # 定义平移矩阵\n    M = np.float32([[1, 0, x], [0, 1, y]])\n    \n    # 使用OpenCV仿射变换函数实现平移操作\n    shifted = cv2.warpAffine(img, M, (w, h))\n​\n    # 返回转换后的图像\n    return shifted\n​\n# 加载图像并显示\nim = cv2.imread(\'/data/CV-ascend/images/panda.png\')\nim_RBG = cv2.cvtColor(im,cv2.COLOR_BGR2RGB)\nplt.figure(figsize=(8,8))\nplt.subplot(2,2,1),plt.title(\'original\'),plt.imshow(im_RBG)\n​\n# 对原图做平移操作\n# 下移50像素\nshifted_60 = translate(im_RBG, 0, 50)\nplt.subplot(2,2,2),plt.title(\'down move 50 pixels\'),plt.imshow(shifted_60)\n# 左移100像素\nshifted_minus100 = translate(im_RBG, -100, 0)\nplt.subplot(2,2,3),plt.title(\'left move 100 pixels\'),plt.imshow(shifted_minus100)\n# 右移50，下移100像素\nshifted_100 = translate(im_RBG, 50, 100)\nplt.subplot(2,2,4),plt.title(\'right move 50,down move 100 pixels\'),plt.imshow(shifted_100)\n输出：\n\n(<matplotlib.axes._subplots.AxesSubplot at 0xfffee00be690>,\n Text(0.5, 1.0, \'right move 50,down move 100 pixels\'),\n <matplotlib.image.AxesImage at 0xfffee0079fd0>)\n\n步骤2 旋转\n输入：\n\n# 定义旋转rotate函数\ndef rotate(img, angle, center=None, scale=1.0):\n    # 获取图像尺寸\n    (h, w) = img.shape[:2]\n​\n    # 旋转中心的缺失值为图像中心\n    if center is None:\n        center = (w / 2, h / 2)\n​\n    # 调用计算旋转矩阵函数\n    M = cv2.getRotationMatrix2D(center, angle, scale)\n    \n    # 使用OpenCV仿射变换函数实现旋转操作\n    rotated = cv2.warpAffine(img, M, (w, h))\n​\n    # 返回旋转后的图像\n    return rotated\n​\n​\nim = cv2.imread(\'/data/CV-ascend/images/panda.png\')\nim_RBG = cv2.cvtColor(im,cv2.COLOR_BGR2RGB)\nplt.figure(figsize=(8,8))\nplt.subplot(2,2,1),plt.title(\'original\'),plt.imshow(im_RBG)\n​\n# 对原图做旋转操作\n# 逆时针45度\nrotated_45 = rotate(im_RBG, 45)\nplt.subplot(2,2,2),plt.title(\'rotate 45 degree counter-clockwise\'),plt.imshow(rotated_45)\n# 顺时针20度\nrotated_minus20 = rotate(im_RBG, -20)\nplt.subplot(2,2,3),plt.title(\'rotate 45 degree clockwise\'),plt.imshow(rotated_minus20)\n# 逆时针90度\nrotated_90 = rotate(im_RBG, 90)\nplt.subplot(2,2,4),plt.title(\'rotate 90 degree counter-clockwise\'),plt.imshow(rotated_90)\n输出：\n\n(<matplotlib.axes._subplots.AxesSubplot at 0xfffed3f3c550>,\n Text(0.5, 1.0, \'rotate 90 degree counter-clockwise\'),\n <matplotlib.image.AxesImage at 0xfffed3ef6ed0>)\n\n步骤3 镜像\n输入：\n\nim = cv2.imread(\'/data/CV-ascend/images/panda.png\')\nim_RBG = cv2.cvtColor(im,cv2.COLOR_BGR2RGB)\nplt.figure(figsize=(8,8))\nplt.subplot(2,2,1),plt.title(\'original\'),plt.imshow(im_RBG)\n​\n# 进行水平镜像\nim_flip0 = cv2.flip(im_RBG, 0)\nplt.subplot(2,2,2),plt.title(\' Mirror Horizontally\'),plt.imshow(im_flip0)\n​\n# 进行垂直镜像\nim_flip1 = cv2.flip(im_RBG, 1)\nplt.subplot(2,2,3),plt.title(\'Mirror Vetically\'),plt.imshow(im_flip1)\n输出：\n\n(<matplotlib.axes._subplots.AxesSubplot at 0xfffed253df10>,\n Text(0.5, 1.0, \'Mirror Vetically\'),\n <matplotlib.image.AxesImage at 0xfffed25008d0>)\n\n步骤4 缩放\n输入：\n\nim = cv2.imread(\'/data/CV-ascend/images/panda.png\')\nim_RBG = cv2.cvtColor(im,cv2.COLOR_BGR2RGB)\nplt.figure(figsize=(8,8))\nplt.subplot(2,2,1),plt.title(\'original\'),plt.imshow(im_RBG)\n​\n# 获取图像尺寸\n(h, w) = im_RBG.shape[:2]\n​\n# 缩放的目标尺寸\ndst_size = (200,300)\n​\n# 最邻近插值\nmethod = cv2.INTER_NEAREST\n​\n# 进行缩放\nresized = cv2.resize(im_RBG, dst_size, interpolation = method)\nplt.subplot(2,2,2),plt.title(\'INTER_NEAREST\'),plt.imshow(resized)\n​\n# 缩放的目标尺寸\ndst_size = (800,600)\n​\n# 双线性插值\nmethod = cv2.INTER_LINEAR\n​\n# 进行缩放\nresized_linear = cv2.resize(im_RBG, dst_size, interpolation = method)\nplt.subplot(2,2,3),plt.title(\'INTER_LINEAR\'),plt.imshow(resized_linear)\n输出：\n\n(<matplotlib.axes._subplots.AxesSubplot at 0xfffed2477490>,\n Text(0.5, 1.0, \'INTER_LINEAR\'),\n <matplotlib.image.AxesImage at 0xfffed2431e10>)\n\n')

def test_print():
    print("我还是想说，这个考试真的愚蠢")


if __name__ == '__main__':
    test_print()
    one()
    two()
    three()
